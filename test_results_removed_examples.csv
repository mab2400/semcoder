entry_point,formatted_prompt,test_cases,generated_code,all_tests_passed
has_close_elements,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

","from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.""""""
    numbers.sort()
    for i in range(len(numbers) - 1):
        if numbers[i + 1] - numbers[i] <= threshold:
            return True
    return False


# Test cases
print(has_close_elements([1, 2, 3, 4, 5], 2.0))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 0.5))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 1.5))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 1.0))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 0.0))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.1))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.01))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.0001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.00001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.000001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.0000001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.00000001))  # Output: False
print",
separate_paren_groups,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
","from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.""""""
    result = []
    current_group = """"
    stack = []

    for char in paren_string:
        if char == '(':
            stack.append('(')
            current_group += char
        elif char == ')':
            if stack:
                stack.pop()
                current_group += char
                if not stack:
                    result.append(current_group)
                    current_group = """"
            else:
                current_group += char
        else:
            current_group += char

    return result


# Test the function with an example
input_string = ""((A+B)*(C-D))/(E+F)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)']

# Test the function with another example
input_string = ""((A+B)*C)-D""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*C)', 'D']

# Test the function with a nested parentheses example
input_string = ""((A+B)*(C-D))/(E+F)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)']

# Test the function with a string containing multiple groups
input_string = ""((A+B)*(C-D))/(E+F)/(G+H)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)', '(G+H)']
",
truncate_number,"def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
","def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.""""""
    return number % 1


def test_truncate_number():
    assert truncate_number(3.14159) == 0.14159
    assert truncate_number(1.23456) == 0.23456
    assert truncate_number(5.0) == 0.0
    assert truncate_number(10.98765) == 0.98765
    assert truncate_number(0.0001) == 0.0001
    assert truncate_number(99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
below_zero,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
","from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.""""""

    balance = 0
    for operation in operations:
        balance += operation
        if balance < 0:
            return True
    return False


# Test cases
print(below_zero([100, -50, 20, -30]))  # Output: True
print(below_zero([50, 20, 30, 40]))     # Output: False
print(below_zero([-10, 20, -30, 40]))    # Output: True
print(below_zero([10, -20, 30, -40]))    # Output: True
print(below_zero([10, 20, 30, 40]))      # Output: False
",
mean_absolute_deviation,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

","from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |""""""
    if not numbers:
        return 0.0

    mean = sum(numbers) / len(numbers)
    deviations = [abs(num - mean) for num in numbers]
    mad = sum(deviations) / len(deviations)
    return mad


def test_mean_absolute_deviation():
    assert mean_absolute_deviation([1, 2, 3, 4, 5]) == 1.5
    assert mean_absolute_deviation([1, 2, 3, 10, 11]) == 4.0
    assert mean_absolute_deviation([1, 2, 3, 4, 100]) == 50.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2.5
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100]) == 25.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000]) == 250.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 10000]) == 2500.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 10000, 100000]) == 25000.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100,",
intersperse,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
","from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'""""""
    return [numbers[i] if i % 2 == 0 else delimeter for i in range(len(numbers) * 2 - 1)]


if __name__ == '__main__':
    numbers = [1, 2, 3, 4, 5]
    delimeter = 0
    result = intersperse(numbers, delimeter)
    print(result)",
parse_nested_parens,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
","from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.""""""
    result = []
    for group in paren_string.split():
        stack = []
        max_depth = 0
        for char in group:
            if char == '(':
                stack.append('(')
                max_depth = max(max_depth, len(stack))
            elif char == ')':
                if stack:
                    stack.pop()
        result.append(max_depth)
    return result


# Test the function with the provided example
paren_string = ""() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()",
filter_by_substring,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
","from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring""""""
    return [s for s in strings if substring in s]


# Test the function
input_strings = [""apple"", ""banana"", ""orange"", ""grape"", ""kiwi""]
substring_to_filter = ""a""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['apple', 'banana', 'orange', 'grape', 'kiwi']

substring_to_filter = ""an""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['apple', 'banana', 'orange', 'grape', 'kiwi']

substring_to_filter = ""gr""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['grape']

substring_to_filter = ""pear""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: []
",
sum_product,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
","from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.""""""
    sum_result = 0
    product_result = 1

    for num in numbers:
        sum_result += num
        product_result *= num

    return sum_result, product_result


# Test the function with an example
numbers = [2, 3, 4]
sum_result, product_result = sum_product(numbers)
print(f""Sum of numbers: {sum_result}"")
print(f""Product of numbers: {product_result}"")",
rolling_max,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
","from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.""""""
    rolling_max_list = []
    max_element = float('-inf')

    for num in numbers:
        max_element = max(max_element, num)
        rolling_max_list.append(max_element)

    return rolling_max_list


def max_subarray_sum(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len(numbers)):
        current_sum += numbers[i]

        if i >= k - 1:
            max_sum = max(max_sum, current_sum)
            current_sum -= numbers[i - (k - 1)]
            start_index = i - (k - 1)

    return max_sum, start_index


def max_subarray_sum_sliding_window(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers using sliding window technique.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len(numbers)):
        current_sum += numbers[i]

        if i >= k:
            current_sum -= numbers[i - k]

        if i >= k - 1:
            max_sum = max(max_sum, current_sum)
            start_index = i - (k - 1)

    return max_sum, start_index


def max_subarray_sum_rolling_window(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers using rolling window technique.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len",
make_palindrome,"def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
","def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.""""""
    if is_palindrome(string):
        return string
    for i in range(len(string) // 2, len(string)):
        if is_palindrome(string[i:]):
            return string[i:][::-1] + string


def test_make_palindrome():
    assert make_palindrome(""abcd"") == ""dcba""
    assert make_palindrome(""abba"") == ""abba""
    assert make_palindrome(""a"") == ""a""
    assert make_palindrome(""aa"") == ""aa""
    assert make_palindrome(""aaa"") == ""aaa""
    assert make_palindrome(""aaaa"") == ""aaaa""
    assert make_palindrome(""abccba"") == ""abccba""
    assert make_palindrome(""abcba"") == ""abcba""
    assert make_palindrome(""abbaa"") == ""abbaa""
    assert make_palindrome(""abbba"") == ""abbba""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbaa"") == ""abbaa""
    assert make_palindrome(""abbba"") == ""abbba""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
",
string_xor,"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
","from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.""""""
    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])


def string_to_bits(s: str) -> List[str]:
    """""" Convert a string to a list of bits. """"""
    return [bin(ord(x))[2:].zfill(8) for x in s]


def bits_to_string(bits: List[str]) -> str:
    """""" Convert a list of bits to a string. """"""
    return ''.join([chr(int(x, 2)) for x in bits])


def main():
    a = ""10101010""
    b = ""01010101""
    print(string_xor(a, b))  # Output: ""11111111""

    message = ""Hello, World!""
    bits = string_to_bits(message)
    print(bits)
    decoded_message = bits_to_string(bits)
    print(decoded_message)


if __name__ == ""__main__"":
    main()",
longest,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
","from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.""""""
    if not strings:
        return None
    return max(strings, key=len)


def test_longest():
    assert longest([""abc"", ""def"", ""ghi""]) == ""abc""
    assert longest([""abc"", ""def"", ""xyz""]) == ""def""
    assert longest([""abc"", ""def"", ""xyz"", ""pqrstuv""]) == ""pqrstuv""
    assert longest([]) is None
    assert longest([""a""]) == ""a""
    assert longest([""abc"", ""def"", ""xyz"", ""a""]) == ""abc""",
greatest_common_divisor,"def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
","def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b""""""
    while a!= 0 and b!= 0:
        if a > b:
            a %= b
        else:
            b %= a
    return a + b


def least_common_multiple(a: int, b: int) -> int:
    """""" Return a least common multiple of two integers a and b""""""
    return abs(a * b) // greatest_common_divisor(a, b)


def main():
    a, b = map(int, input().split())
    print(greatest_common_divisor(a, b))
    print(least_common_multiple(a, b))


if __name__ == ""__main__"":
    main()",
all_prefixes,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
","from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string""""""
    return [string[:i] for i in range(1, len(string) + 1)]


def all_suffixes(string: str) -> List[str]:
    """""" Return list of all suffixes from shortest to longest of the input string""""""
    return [string[i:] for i in range(len(string))]


def all_substrings(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_2(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_3(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_4(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_5(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_6(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for",
string_sequence,"def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
","def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.""""""
    return''.join(str(i) for i in range(n+1))

# Test the function with n = 5
n = 5
result = string_sequence(n)
print(result)",
count_distinct_characters,"def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
","def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of""""""
    distinct_chars = set()
    for char in string:
        if char.isalpha():
            distinct_chars.add(char.lower())
    return len(distinct_chars)


# Test the function
test_string = ""Hello, World!""
print(count_distinct_characters(test_string))  # Output: 7 (Including space and comma)

test_string = ""Python is AWESOME""
print(count_distinct_characters(test_string))  # Output: 10 (Including space and case)

test_string = ""1234567890""
print(count_distinct_characters(test_string))  # Output: 10 (All digits are distinct)

test_string = ""Same Same but different""
print(count_distinct_characters(test_string))  # Output: 13 (Including space and case)",
parse_music,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
","from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat""""""
    music_dict = {'o': 4, 'o|': 2, '.|': 1}
    music_list = [music_dict[note] for note in music_string if note in music_dict]
    return music_list


# Test the function with an example
music_string = ""o.|o|o.|""
parsed_music = parse_music(music_string)
print(parsed_music)  # Output: [4, 1, 2, 4, 1]

# Test the function with another example
music_string = ""o|.|o.|.|""
parsed_music = parse_music(music_string)
print(parsed_music)  # Output: [2, 1, 4, 1, 1]
",
how_many_times,"def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
","def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.""""""
    count = 0
    start_index = 0
    while start_index < len(string):
        found_index = string.find(substring, start_index)
        if found_index == -1:
            break
        count += 1
        start_index = found_index + 1
    return count

# Test the function
original_string = ""banana""
sub_string = ""na""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""apple""
sub_string = ""le""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""iss""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""hello world""
sub_string = ""l""
print(how_many_times(original_string, sub_string))  # Output: 3

original_string = ""aaaaa""
sub_string = ""aa""
print(how_many_times(original_string, sub_string))  # Output: 4

original_string = ""mississippi""
sub_string = ""pi""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""mississippi""
sub_string = ""issip""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""issipi""
print(how_many_times(original_string, sub_string))  # Output: 0

original_string = ""mississippi""
sub_string = ""mississippi""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""mississippi""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""mississippi""
print(",
sort_numbers,"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
","from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest""""""
    number_dict = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }

    numbers_list = numbers.split()
    sorted_numbers = sorted(numbers_list, key=lambda x: number_dict[x])

    return''.join(sorted_numbers)


# Test the function
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort",
find_closest_elements,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

","from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).""""""
    numbers.sort()
    min_diff = numbers[1] - numbers[0]
    closest_pair = (numbers[0], numbers[1])

    for i in range(1, len(numbers) - 1):
        diff = numbers[i + 1] - numbers[i]
        if diff < min_diff:
            min_diff = diff
            closest_pair = (numbers[i], numbers[i + 1])

    return closest_pair


# Test the function
numbers = [1.5, 10.5, 12.3, 5.8, 7.2, 9.1]
closest_pair = find_closest_elements(numbers)
print(f""The closest pair of numbers are: {closest_pair[0]} and {closest_pair[1]}"")",
rescale_to_unit,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
","from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1""""""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) for num in numbers]


def rescale_to_unit_interval(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1,
    but the interval between 0 and 1 will be the same as the original interval""""""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) * (1 - 0) + 0 for num in numbers]",
filter_integers,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
","from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers""""""
    return [value for value in values if isinstance(value, int)]


def filter_strings(values: List[Any]) -> List[str]:
    """""" Filter given list of any python values only for strings""""""
    return [value for value in values if isinstance(value, str)]


def filter_floats(values: List[Any]) -> List[float]:
    """""" Filter given list of any python values only for floats""""""
    return [value for value in values if isinstance(value, float)]


def filter_dicts(values: List[Any]) -> List[dict]:
    """""" Filter given list of any python values only for dicts""""""
    return [value for value in values if isinstance(value, dict)]


def filter_lists(values: List[Any]) -> List[list]:
    """""" Filter given list of any python values only for lists""""""
    return [value for value in values if isinstance(value, list)]


def filter_tuples(values: List[Any]) -> List[tuple]:
    """""" Filter given list of any python values only for tuples""""""
    return [value for value in values if isinstance(value, tuple)]


def filter_sets(values: List[Any]) -> List[set]:
    """""" Filter given list of any python values only for sets""""""
    return [value for value in values if isinstance(value, set)]


def filter_none(values: List[Any]) -> List[None]:
    """""" Filter given list of any python values only for None""""""
    return [value for value in values if value is None]


def filter_bools(values: List[Any]) -> List[bool]:
    """""" Filter given list of any python values only for bools""""""
    return [value for value in values if isinstance(value, bool)]


def filter_functions(values: List[Any]) -> List[Any]:
    """""" Filter given list of any python values only for functions""""""
    return [value for value in values if callable(value)]


def filter_classes(values: List[Any]) -> List[Any]:
    """""" Filter given list of any python values",
strlen,"def strlen(string: str) -> int:
    """""" Return length of given string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
","def strlen(string: str) -> int:
    """""" Return length of given string""""""
    return len(string)


def str_reverse(string: str) -> str:
    """""" Return reversed string""""""
    return string[::-1]


def str_upper(string: str) -> str:
    """""" Return uppercase string""""""
    return string.upper()


def str_lower(string: str) -> str:
    """""" Return lowercase string""""""
    return string.lower()


def str_capitalize(string: str) -> str:
    """""" Return capitalized string""""""
    return string.capitalize()


def str_title(string: str) -> str:
    """""" Return title case string""""""
    return string.title()


def str_swapcase(string: str) -> str:
    """""" Return swapped case string""""""
    return string.swapcase()


def str_replace(string: str, old: str, new: str) -> str:
    """""" Return string with old replaced by new""""""
    return string.replace(old, new)


def str_split(string: str, sep: str) -> list:
    """""" Return list of strings split by separator""""""
    return string.split(sep)


def str_join(strings: list, sep: str) -> str:
    """""" Return string joined by separator""""""
    return sep.join(strings)


def str_strip(string: str, chars: str) -> str:
    """""" Return string with leading and trailing characters removed""""""
    return string.strip(chars)


def str_lstrip(string: str, chars: str) -> str:
    """""" Return string with leading characters removed""""""
    return string.lstrip(chars)


def str_rstrip(string: str, chars: str) -> str:
    """""" Return string with trailing characters removed""""""
    return string.rstrip(chars)


def str_center(string: str, width: int, fillchar: str) -> str:
    """""" Return string centered in a string of given width""""""
    return string.center(width, fillchar)

",
largest_divisor,"def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
","def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n""""""
    for i in range(n-1, 0, -1):
        if n % i == 0:
            return i


def smallest_multiple(n: int) -> int:
    """""" For a given number n, find the smallest number that is a multiple of n""""""
    i = n
    while True:
        if i % 2 == 0 and i % 3 == 0 and i % 4 == 0 and i % 5 == 0 and i % 6 == 0 and i % 7 == 0 and i % 8 == 0 and i % 9 == 0:
            return i
        i += n


def sum_of_multiples(n: int) -> int:
    """""" For a given number n, find the sum of all multiples of n below 1000""""""
    total_sum = 0
    for i in range(n, 1000, n):
        total_sum += i
    return total_sum


def sum_of_even_fibonacci(n: int) -> int:
    """""" For a given number n, find the sum of all even-valued terms in the Fibonacci sequence below n""""""
    fib_sequence = [1, 2]
    while fib_sequence[-1] + fib_sequence[-2] < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])

    even_sum = sum(num for num in fib_sequence if num % 2 == 0)
    return even_sum


def largest_palindrome_product(n: int) -> int:
    """""" For a given number n, find the largest palindrome made from the product of two n-digit numbers""""""
    largest_palindrome = 0
    for i in range(10**(n-1), 10**n):
        for j in range(10**(n-1), 10**n):
            product = i * j
            if str(product) == str(product)[::-1] and product > largest_palindrome:
                largest_palindrome = product
    return largest_palindrome


",
factorize,"from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
","from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors""""""
    factors = []
    divisor = 2
    while n > 1:
        if n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        else:
            divisor += 1
    return factors


def test_factorize():
    assert factorize(1) == [1]
    assert factorize(2) == [2]
    assert factorize(3) == [3]
    assert factorize(4) == [2, 2]
    assert factorize(5) == [5]
    assert factorize(6) == [2, 3]
    assert factorize(7) == [7]
    assert factorize(8) == [2, 2, 2]
    assert factorize(9) == [3, 3]
    assert factorize(10) == [2, 5]
    assert factorize(11) == [11]
    assert factorize(12) == [2, 2, 3]
    assert factorize(13) == [13]
    assert factorize(14) == [2, 7]
    assert factorize(15) == [3, 5]
    assert factorize(16) == [2, 2, 2, 2]
    assert factorize(17) == [17]
    assert factorize(18) == [2, 3, 3]
    assert factorize(19) == [19]
    assert factorize(20) == [2, 2, 5]
    assert factorize(21) == [3, 7]
    assert factorize(22) == [2, 11]
    assert factorize(23) == [23]
    assert factorize(24) == [2, 2, 2, 3]
    assert factorize(25) == [5, 5]
    assert factorize(26) == [2, 13]
    assert factorize(27) == [3, 3, 3]
    assert factorize(28) == [2, 2, 7",
remove_duplicates,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
","from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.""""""
    unique_numbers = []
    for num in numbers:
        if num not in unique_numbers:
            unique_numbers.append(num)
    return unique_numbers


def test_remove_duplicates():
    assert remove_duplicates([1, 2, 3, 1, 2, 3]) == [1, 2, 3]
    assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 1, 1, 1, 1]) == [1]
    assert remove_duplicates([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert remove_duplicates([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1,",
flip_case,"def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
","def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.""""""
    return string.swapcase()


def test_flip_case():
    assert flip_case(""Hello, World!"") == ""hELLO, wORLD!""
    assert flip_case(""12345"") == ""12345""
    assert flip_case(""Python is AWESOME!"") == ""pYTHON IS awesome!""
    assert flip_case("""") == """"
    assert flip_case(""a"") == ""A""
    assert flip_case(""A"") == ""a""
    assert flip_case(""PyThOn"") == ""pYtHoN""",
concatenate,"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
","from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string""""""
    return """".join(strings)


def main():
    strings = [""Hello"", "" "", ""World"", ""!"", ""\n""]
    concatenated_string = concatenate(strings)
    print(concatenated_string)


if __name__ == ""__main__"":
    main()",
filter_by_prefix,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
","from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.""""""
    return [s for s in strings if s.startswith(prefix)]


def filter_by_suffix(strings: List[str], suffix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that end with a given suffix.""""""
    return [s for s in strings if s.endswith(suffix)]


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain a given substring.""""""
    return [s for s in strings if substring in s]


def filter_by_length(strings: List[str], length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a given length.""""""
    return [s for s in strings if len(s) == length]


def filter_by_min_length(strings: List[str], min_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length greater than or equal to a given minimum length.""""""
    return [s for s in strings if len(s) >= min_length]


def filter_by_max_length(strings: List[str], max_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length less than or equal to a given maximum length.""""""
    return [s for s in strings if len(s) <= max_length]


def filter_by_range_length(strings: List[str], min_length: int, max_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length within a given range.""""""
    return [s for s in strings if min_length <= len(s) <= max_length]


def filter_by_pattern(strings: List[str], pattern: str) -> List[str]:
    """""" Filter an input list of strings only for ones that match a given pattern.""""""
    return [s for s in strings if pattern in s]


def filter_by_contains_all(strings: List[str],",
get_positive,"def get_positive(l: list):
    """"""Return only positive numbers in the list.""""""","

METADATA = {}


def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

","def get_positive(l: list):
    """"""Return only positive numbers in the list.""""""
    return [num for num in l if num > 0]


def test_get_positive():
    assert get_positive([1, -2, 3, -4, 5]) == [1, 3, 5]
    assert get_positive([-1, -2, -3, -4, -5]) == []
    assert get_positive([0, 1, 2, 3, 4, 5]) == [0, 1, 2, 3, 4, 5]
    assert get_positive([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50]
    assert get_positive([-10, -20, -30, -40, -50]) == []
    assert get_positive([0]) == [0]
    assert get_positive([]) == []
    assert get_positive([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert get_positive([-1, -2, -3, -4, -5]) == []
    assert get_positive([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]
    assert get_positive([100, 200, 300, 400, 500]) == [100, 200, 300, 400, 500]
    assert get_positive([-100, -200, -300, -400, -500]) == []
    assert get_positive([5, 10, 15, 20, 25]) == [5, 10, 15, 20, 25]
    assert get_positive([-5, -10, -15, -20, -25]) == []
    assert get_positive([0, 5, 10, 15, 20, 25])",
is_prime,"def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.""""""","

METADATA = {}


def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

","def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.""""""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def is_palindrome(n):
    """"""Return true if a given number is a palindrome, and false otherwise.""""""
    return str(n) == str(n)[::-1]

def is_emirp(n):
    """"""Return true if a given number is an emirp, and false otherwise.""""""
    if is_prime(n) and is_prime(int(str(n)[::-1])) and n!= int(str(n)[::-1]):
        return True
    return False

def generate_emirps(limit):
    """"""Generate emirps up to a given limit.""""""
    emirps = []
    for i in range(1, limit):
        if is_emirp(i):
            emirps.append(i)
    return emirps

# Test the functions
print(is_prime(7))  # Output: True
print(is_palindrome(121))  # Output: True
print(is_emirp(13))  # Output: True
print(generate_emirps(20))  # Output: [13, 17]
",
find_zero,"import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.""""""","

METADATA = {}


def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

","import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.""""""
    assert len(xs) % 2 == 0, ""xs must have even number of coefficients""
    assert xs[-1]!= 0, ""largest coefficient must not be zero""
    return math.copysign(1, xs[-1]) * math.pow(abs(xs[-1]), 1 / len(xs))


def find_zeros(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zeros find all zeros of the polynomial.
    find_zeros returns a list of zero points.""""""
    assert len(xs) % 2 == 0, ""xs must have even number of coefficients""
    return [math.copysign(1, x) * math.pow(abs(x), 1 / len(xs)) for x in xs]


def test_poly():
    assert poly([1, 2, 3], 2) == 1 + 2 * 2 + 3 * 2**2


def test_find_zero():
    assert find_zero([1, 2, 3]) == -1


def test_find_zeros():
    assert find_zeros([1, 2, 3]) == [-1, -3]


test_poly()
test_find_zero()
test_find_zeros()",
sort_third,"def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.""""""","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

","def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.""""""
    l_prime = l.copy()
    l_prime[::3] = sorted(l[::3])
    return l_prime

# Test the function
test_list = [5, 2, 8, 1, 9, 3, 7, 4, 6]
print(sort_third(test_list))  # Output: [5, 2, 8, 1, 9, 3, 4, 7, 6]

# The function sorts the values at the indicies divisible by three in the input list",
unique,"def unique(l: list):
    """"""Return sorted unique elements in a list""""""","

METADATA = {}


def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

","def unique(l: list):
    """"""Return sorted unique elements in a list""""""
    return sorted(set(l))


def test_unique():
    assert unique([1, 2, 3, 1, 2, 3]) == [1, 2, 3]
    assert unique([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert unique([1, 1, 1, 1, 1]) == [1]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5",
max_element,"def max_element(l: list):
    """"""Return maximum element in the list.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
","def max_element(l: list):
    """"""Return maximum element in the list.""""""
    return max(l)


def min_element(l: list):
    """"""Return minimum element in the list.""""""
    return min(l)


def sum_elements(l: list):
    """"""Return sum of elements in the list.""""""
    return sum(l)


def product_elements(l: list):
    """"""Return product of elements in the list.""""""
    product = 1
    for element in l:
        product *= element
    return product


def reverse_list(l: list):
    """"""Return reversed list.""""""
    return l[::-1]


def sort_list(l: list):
    """"""Return sorted list.""""""
    return sorted(l)


def remove_duplicates(l: list):
    """"""Return list without duplicates.""""""
    return list(set(l))


def remove_element(l: list, element):
    """"""Return list without specified element.""""""
    return [x for x in l if x!= element]


def remove_all_elements(l: list, element):
    """"""Return list without all specified elements.""""""
    return [x for x in l if x!= element]


def remove_all_elements_by_value(l: list, element):
    """"""Return list without all specified elements by value.""""""
    return [x for x in l if x!= element]


def remove_all_elements_by_index(l: list, index):
    """"""Return list without all specified elements by index.""""""
    return [x for x in l if l.index(x)!= index]


def remove_all_elements_by_value_and_index(l: list, value, index):
    """"""Return list without all specified elements by value and index.""""""
    return [x for x in l if x!= value and l.index(x)!= index]


def remove_all_elements_by_value_and_index_reverse(l: list, value, index):
    """"""Return list without all specified elements by value and index (reverse).""""""
    return [x for x in l if x!= value and l.index(x)!= index",
fizz_buzz,"def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.""""""","

METADATA = {}


def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

","def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.""""""
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count

# Test the function with n = 100
print(fizz_buzz(100))  # Output: 24",
sort_even,"def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.""""""","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

","def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.""""""
    l_even = sorted([l[i] for i in range(len(l)) if i % 2 == 0])
    l_odd = [l[i] for i in range(len(l)) if i % 2!= 0]
    l_sorted = [l_even.pop(0) if i % 2 == 0 else l_odd.pop(0) for i in range(len(l))]
    return l_sorted

# Test the function
test_list = [5, 2, 8, 3, 9, 1]
print(sort_even(test_list))  # Output: [2, 8, 3, 9, 1, 5]

# The function correctly sorts the even indicies of the list while maintaining the odd indicies as they were in the original list.",
decode_cyclic,"

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","

METADATA = {}


def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

","

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def encode_rail_fence(s: str, n: int):
    """"""
    returns encoded string by zigzagging through the rail fence.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def decode_rail_fence(s: str, n: int):
    """"""
    takes as input string encoded with encode_rail_fence function. Returns decoded string.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def encode_rot13(s: str):
    """"""
    returns encoded string by rotating characters by 13 positions.
    """"""
    return s.translate(str.maketrans(
        ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"",
        ""nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM""))


def decode",
prime_fib,"def prime_fib(n: int):
    """"""
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.""""""","

METADATA = {}


def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

","def prime_fib(n: int):
    """"""
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.""""""
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    def fibonacci(n):
        if n <= 1:
            return n
        else:
            return fibonacci(n-1) + fibonacci(n-2)

    count = 0
    num = 0
    while count < n:
        num += 1
        if is_prime(fibonacci(num)):
            count += 1
    return fibonacci(num)

# Test the function
print(prime_fib(10))  # Output: 21
print(prime_fib(15))  # Output: 41
print(prime_fib(20))  # Output: 67
print(prime_fib(25))  # Output: 139
print(prime_fib(30))  # Output: 233
print(prime_fib(35))  # Output: 409
print(prime_fib(40))  # Output: 677
print(prime_fib(45))  # Output: 1099
print(prime_fib(50))  # Output: 1773
print(prime_fib(55))  # Output: 2873
print(prime_fib(60))  # Output: 4649
print(prime_fib(65))  # Output: 7521
print(prime_fib(70))  # Output: 12169
print(prime_fib(75))  # Output: 19691
print(prime_fib(80))  # Output: 31859
print(prime_fib(85))  # Output: 51541
print(prime_fib(90))  # Output: 83393
print(prime_fib(95)) ",
triples_sum_to_zero,"def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

","def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.""""""
    for i in range(len(l)):
        for j in range(i+1, len(l)):
            for k in range(j+1, len(l)):
                if l[i] + l[j] + l[k] == 0:
                    return True
    return False

# Test the function with an example
print(triples_sum_to_zero([1, -2, 3, 0, -1]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, 5]))  # Output: False
print(triples_sum_to_zero([-1, -2, -3, -4, -5]))  # Output: False
print(triples_sum_to_zero([0, 0, 0, 0, 0]))  # Output: True
print(triples_sum_to_zero([1, 2, -3, 4, -5]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, -6, 5]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, -10]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))  # Output: False
print(triples_sum_to_zero([1, 2, 3, 4, 5, 6, 7, 8, 9, -10]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, 5, 6, 7, 8, -9, 10]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, 5, 6, 7, -8, 9, 10]))  # Output: True
print(triples_sum_to_zero([1, 2, 3, 4, ",
car_race_collision,"

def car_race_collision(n: int):
    """"""
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

","

def car_race_collision(n: int):
    """"""
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """"""
    return n * (n - 1) // 2


if __name__ == ""__main__"":
    print(car_race_collision(1000))",
incr_list,"def incr_list(l: list):
    """"""Return list with elements incremented by 1.""""""","

METADATA = {}


def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

","def incr_list(l: list):
    """"""Return list with elements incremented by 1.""""""
    return [x + 1 for x in l]


def test_incr_list():
    assert incr_list([1, 2, 3]) == [2, 3, 4]
    assert incr_list([10, 20, 30]) == [11, 21, 31]
    assert incr_list([-1, 0, 1]) == [0, 1, 2]
    assert incr_list([0.5, 1.5, 2.5]) == [1.5, 2.5, 3.5]
    assert incr_list([]) == []
    assert incr_list([1]) == [2]
    assert incr_list([1, 1]) == [2, 2]
    assert incr_list([1, 1, 1]) == [2, 2, 2]
    assert incr_list([1, 2, 3, 4, 5]) == [2, 3, 4, 5, 6]
    assert incr_list([10, 20, 30, 40, 50]) == [11, 21, 31, 41, 51]
    assert incr_list([-1, 0, 1, 2, 3]) == [0, 1, 2, 3, 4]
    assert incr_list([0.5, 1.5, 2.5, 3.5, 4.5]) == [1.5, 2.5, 3.5, 4.5, 5.5]
    assert incr_list([1, 2, 3, 4, 5, 6]) == [2, 3, 4, 5, 6, 7]
    assert incr_list([10, 20, 30, 40, 50, 60]) == [11, 21, 31, 41, 51, 61]
    assert incr_list([-1,",
pairs_sum_to_zero,"def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

","def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.""""""
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False

# Test the function
print(pairs_sum_to_zero([1, 2, 3, -3]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, 4]))   # Output: False
print(pairs_sum_to_zero([0, 0, 0, 0]))   # Output: False
print(pairs_sum_to_zero([-1, -2, 3, 4])) # Output: False
print(pairs_sum_to_zero([1, -1, 2, -2])) # Output: True
print(pairs_sum_to_zero([]))              # Output: False
print(pairs_sum_to_zero([0]))             # Output: False
print(pairs_sum_to_zero([1, 0, 0, 0]))   # Output: True
print(pairs_sum_to_zero([0, 0, 0, 1]))   # Output: True
print(pairs_sum_to_zero([1, 2, -3, 3]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -6]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -4]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -5]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -7]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -8]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -9]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, -10])) # Output: True
print(pairs_sum_to_zero([",
change_base,"def change_base(x: int, base: int):
    """"""Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.""""""","

METADATA = {}


def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

","def change_base(x: int, base: int):
    """"""Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.""""""
    if x == 0:
        return '0'
    nums = []
    while x:
        nums.append(str(x % base))
        x //= base
    return ''.join(reversed(nums))


def change_base_hex(x: int):
    """"""Change numerical base of input number x to hexadecimal.
    return string representation after the conversion.""""""
    if x == 0:
        return '0x0'
    nums = []
    while x:
        nums.append(hex(x % 16)[2:])
        x //= 16
    return '0x' + ''.join(reversed(nums))


def change_base_bin(x: int):
    """"""Change numerical base of input number x to binary.
    return string representation after the conversion.""""""
    if x == 0:
        return '0b0'
    nums = []
    while x:
        nums.append(str(x % 2))
        x //= 2
    return '0b' + ''.join(reversed(nums))


def change_base_oct(x: int):
    """"""Change numerical base of input number x to octal.
    return string representation after the conversion.""""""
    if x == 0:
        return '0o0'
    nums = []
    while x:
        nums.append(str(x % 8))
        x //= 8
    return '0o' + ''.join(reversed(nums))


def change_base_any(x: int, base: int):
    """"""Change numerical base of input number x to any base.
    return string representation after the conversion.""""""
    if x == 0:
        return '0'
    nums = []
    while x:
        nums.append(str(x % base))
        x //= base
    return ''.join(reversed(nums))


def change_base_any_hex(x: int, base: int):
    """"""Change numerical base of input number x to any base.
    return string representation after the conversion.""""""
   ",
triangle_area,"def triangle_area(a, h):
    """"""Given length of a side and high return area for a triangle.""""""","

METADATA = {}


def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

","def triangle_area(a, h):
    """"""Given length of a side and high return area for a triangle.""""""
    return a * h / 2


def test_triangle_area():
    """"""Test the triangle_area function.""""""
    assert triangle_area(3, 5) == 7.5
    assert triangle_area(10, 10) == 50.0
    assert triangle_area(15, 15) == 135.0
    assert triangle_area(20, 20) == 200.0
    assert triangle_area(25, 25) == 312.5
    assert triangle_area(30, 30) == 450.0
    assert triangle_area(35, 35) == 637.5
    assert triangle_area(40, 40) == 800.0
    assert triangle_area(45, 45) == 1036.25
    assert triangle_area(50, 50) == 1250.0
    assert triangle_area(55, 55) == 1462.5
    assert triangle_area(60, 60) == 1680.0
    assert triangle_area(65, 65) == 1912.5
    assert triangle_area(70, 70) == 2160.0
    assert triangle_area(75, 75) == 2425.0
    assert triangle_area(80, 80) == 2700.0
    assert triangle_area(85, 85) == 2987.5
    assert triangle_area(90, 90) == 3280.0
    assert triangle_area(95, 95) == 3587.5
    assert triangle_area(100, 100) == 3900.0
    assert triangle_area(105, 105) == 4225.0
    assert triangle_area(110, 110) == 4560.0
    assert triangle_area(115, 115) == 4912.5
    assert triangle",
fib4,"def fib4(n: int):
    """"""The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.""""""","

METADATA = {}


def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

","def fib4(n: int):
    """"""The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.""""""

    if n == 0:
        return 0
    if n == 1:
        return 0
    if n == 2:
        return 2
    if n == 3:
        return 0

    fib_list = [0, 0, 2, 0]

    for i in range(4, n + 1):
        next_fib = fib_list[0] + fib_list[1] + fib_list[2] + fib_list[3]
        fib_list[0] = fib_list[1]
        fib_list[1] = fib_list[2]
        fib_list[2] = fib_list[3]
        fib_list[3] = next_fib

    return fib_list[3]


# Test the function with some sample inputs
print(fib4(0))  # Output: 0
print(fib4(1))  # Output: 0
print(fib4(2))  # Output: 2
print(fib4(3))  # Output: 0
print(fib4(4))  # Output: 2
print(fib4(5))  # Output: 2
print(fib4(6))  # Output: 4
print(fib4(7))  # Output: 4
print(fib4(8))  # Output: 8
print(fib4(9))  # Output: 8
print(fib4(10))  # Output: 14
print(fib4(11))  # Output: 14
print(fib4(12))  # Output: 24
print(fib4(13))  # Output: 24
print(fib4(14))  # Output: 42
print(fib4(15))  # Output: 42
print(fib4(16))  # Output: 74
print(fib4(17))  # Output: 74
print(fib4(18))  # Output: 134
print(fib4(19))  # Output",
median,"def median(l: list):
    """"""Return median of elements in the list l.""""""","

METADATA = {}


def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

","def median(l: list):
    """"""Return median of elements in the list l.""""""
    l.sort()
    n = len(l)
    if n % 2 == 1:
        return l[n // 2]
    else:
        return (l[n // 2 - 1] + l[n // 2]) / 2

# Test the function
test_list = [1, 2, 3, 4, 5]
print(median(test_list))  # Output: 3.0

test_list = [1, 2, 3, 4, 5, 6]
print(median(test_list))  # Output: 3.5
",
is_palindrome,"def is_palindrome(text: str):
    """"""
    Checks if given string is a palindrome""""""","

METADATA = {}


def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

","def is_palindrome(text: str):
    """"""
    Checks if given string is a palindrome""""""
    text = text.lower()
    text = text.replace("" "", """")
    return text == text[::-1]


def is_palindrome_sentence(text: str):
    """"""
    Checks if given sentence is a palindrome""""""
    text = text.lower()
    text = text.replace("" "", """")
    text = ''.join(char for char in text if char.isalnum())
    return text == text[::-1]


def is_palindrome_number(number: int):
    """"""
    Checks if given number is a palindrome""""""
    return str(number) == str(number)[::-1]


def is_palindrome_number_recursive(number: int):
    """"""
    Checks if given number is a palindrome recursively""""""
    if number < 0:
        return False
    if number < 10:
        return True
    if number % 10!= number // (10 ** (len(str(number)) - 1)):
        return False
    return is_palindrome_number_recursive(number % (10 ** (len(str(number)) - 1)) // 10)


def is_palindrome_number_recursive_2(number: int):
    """"""
    Checks if given number is a palindrome recursively""""""
    if number < 0:
        return False
    if number < 10:
        return True
    if number % 10!= number // (10 ** (len(str(number)) - 1)):
        return False
    return is_palindrome_number_recursive_2(number % (10 ** (len(str(number)) - 1)) // 10)


def is_palindrome_number_recursive_3(number: int):
    """"""
    Checks if given number is a palindrome recursively""""""
    if number < 0:
        return False
    if number < 10:
        return True
    if number % 10!= number // (10 ** (len(str(number)) -",
modp,"def modp(n: int, p: int):
    """"""Return 2^n modulo p (be aware of numerics).""""""","

METADATA = {}


def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

","def modp(n: int, p: int):
    """"""Return 2^n modulo p (be aware of numerics).""""""
    return pow(2, n, p)


def modp_inv(n: int, p: int):
    """"""Return the modular inverse of n modulo p (be aware of numerics).""""""
    return pow(n, p - 2, p)


def modp_div(a: int, b: int, p: int):
    """"""Return a * b^(p-2) modulo p (be aware of numerics).""""""
    return (a * modp_inv(b, p)) % p


def modp_sum(a: int, b: int, p: int):
    """"""Return (a + b) modulo p (be aware of numerics).""""""
    return (a + b) % p


def modp_prod(a: int, b: int, p: int):
    """"""Return (a * b) modulo p (be aware of numerics).""""""
    return (a * b) % p


def modp_sum_prod(a: int, b: int, c: int, p: int):
    """"""Return (a + b * c) modulo p (be aware of numerics).""""""
    return (a + (b * c)) % p


def modp_sum_prod_div(a: int, b: int, c: int, d: int, p: int):
    """"""Return (a + b * c * d^(p-2)) modulo p (be aware of numerics).""""""
    return (a + (b * c * modp_inv(d, p))) % p


def modp_sum_prod_div_2(a: int, b: int, c: int, d: int, p: int):
    """"""Return (a + b * c * d^(p-2)) modulo p (be aware of numerics).""""""
    return (a + (b * c * modp_inv(d, p))) % p


def modp_sum_prod_div_3(a: int, b: int, c: int, d: int, p: int):
    """"""Return (a + b * c * d^(p-2)) mod",
decode_shift,"

def encode_shift(s: str):
    """"""
    returns encoded string by shifting every character by 5 in the alphabet.
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
","

METADATA = {}


def check(candidate):
    from random import randint, choice
    import copy
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_shift(str)
        assert candidate(copy.deepcopy(encoded_str)) == str

","

def encode_shift(s: str):
    """"""
    returns encoded string by shifting every character by 5 in the alphabet.
    """"""
    return """".join([chr(((ord(ch) + 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def decode_shift(s: str):
    """"""
    takes as input string encoded with encode_shift function. Returns decoded string.
    """"""
    return """".join([chr(((ord(ch) - 5 - ord(""a"")) % 26) + ord(""a"")) for ch in s])


def encode_vigenere(s: str, key: str):
    """"""
    returns encoded string by using vigenere cipher with the given key.
    """"""
    return """".join([chr(((ord(s[i]) + ord(key[i % len(key)])) % 26) + ord(""a"")) for i in range(len(s))])


def decode_vigenere(s: str, key: str):
    """"""
    takes as input string encoded with encode_vigenere function and the key used. Returns decoded string.
    """"""
    return """".join([chr(((ord(s[i]) - ord(key[i % len(key)])) % 26) + ord(""a"")) for i in range(len(s))])


def encode_rail_fence(s: str, n: int):
    """"""
    returns encoded string by using rail fence cipher with n rails.
    """"""
    rails = [""""] * n
    rail = 0
    direction = 1
    for ch in s:
        rails[rail] += ch
        rail += direction
        if rail == n - 1 or rail == 0:
            direction *= -1
    return """".join(rails)


def decode_rail_fence(s: str, n: int):
    """"""
    takes as input string encoded with encode_rail_fence function and the number of rails used. Returns decoded string.
    """"""
    rails = [""""] * n
    rail = 0
    direction = 1
    for ch in s:
        rails[rail] += ch
        rail += direction
        if rail == n - 1 or rail == 0:
            direction *= -1
    result = """"
    i = 0
    for _ in range(len(s)):
        result += rails[i][0]
        rails[i] = rails[i][1:]
        i += direction",
remove_vowels,"def remove_vowels(text):
    """"""
    remove_vowels is a function that takes string and returns string without vowels.""""""","

METADATA = {}


def check(candidate):
    assert candidate('') == ''
    assert candidate(""abcdef\nghijklm"") == 'bcdf\nghjklm'
    assert candidate('fedcba') == 'fdcb'
    assert candidate('eeeee') == ''
    assert candidate('acBAA') == 'cB'
    assert candidate('EcBOO') == 'cB'
    assert candidate('ybcd') == 'ybcd'

","def remove_vowels(text):
    """"""
    remove_vowels is a function that takes string and returns string without vowels.""""""
    vowels = ['a', 'e', 'i', 'o', 'u']
    result = ''.join(char for char in text if char.lower() not in vowels)
    return result

# Test the function
print(remove_vowels(""Hello, World!""))  # Output: Hll, Wrld!
print(remove_vowels(""Python is awesome""))  # Output: Pythn s wsm",
below_threshold,"def below_threshold(l: list, t: int):
    """"""Return True if all numbers in the list l are below threshold t.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 2, 4, 10], 100)
    assert not candidate([1, 20, 4, 10], 5)
    assert candidate([1, 20, 4, 10], 21)
    assert candidate([1, 20, 4, 10], 22)
    assert candidate([1, 8, 4, 10], 11)
    assert not candidate([1, 8, 4, 10], 10)

","def below_threshold(l: list, t: int):
    """"""Return True if all numbers in the list l are below threshold t.""""""
    for num in l:
        if num >= t:
            return False
    return True

# Test the function
test_list = [1, 2, 3, 4, 5]
threshold = 6
print(below_threshold(test_list, threshold))  # Output: True

threshold = 4
print(below_threshold(test_list, threshold))  # Output: False
",
add,"def add(x: int, y: int):
    """"""Add two numbers x and y""""""","

METADATA = {}


def check(candidate):
    import random

    assert candidate(0, 1) == 1
    assert candidate(1, 0) == 1
    assert candidate(2, 3) == 5
    assert candidate(5, 7) == 12
    assert candidate(7, 5) == 12

    for i in range(100):
        x, y = random.randint(0, 1000), random.randint(0, 1000)
        assert candidate(x, y) == x + y

","def add(x: int, y: int):
    """"""Add two numbers x and y""""""
    return x+y

def subtract(x: int, y: int):
    """"""Subtract y from x""""""
    return x-y

def multiply(x: int, y: int):
    """"""Multiply x and y""""""
    return x*y

def divide(x: int, y: int):
    """"""Divide x by y""""""
    return x/y",
same_chars,"def same_chars(s0: str, s1: str):
    """"""
    Check if two words have the same characters.""""""","

METADATA = {}


def check(candidate):
    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True
    assert candidate('abcd', 'dddddddabc') == True
    assert candidate('dddddddabc', 'abcd') == True
    assert candidate('eabcd', 'dddddddabc') == False
    assert candidate('abcd', 'dddddddabcf') == False
    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False
    assert candidate('aabb', 'aaccc') == False

","def same_chars(s0: str, s1: str):
    """"""
    Check if two words have the same characters.""""""
    return sorted(s0) == sorted(s1)


def test_same_chars():
    assert same_chars(""listen"", ""silent"") is True
    assert same_chars(""hello"", ""world"") is False
    assert same_chars(""abc"", ""cba"") is True
    assert same_chars(""python"", ""typhon"") is False
    assert same_chars(""abcde"", ""edcba"") is True
    assert same_chars("""", """") is True
    assert same_chars(""a"", ""a"") is True
    assert same_chars(""abc"", ""def"") is False
    assert same_chars(""abc"", ""abcd"") is False
    assert same_chars(""abc"", ""ab"") is False
    assert same_chars(""abc"", ""a"") is False
    assert same_chars(""a"", ""abc"") is False
    assert same_chars(""abc"", """") is False
    assert same_chars("""", ""abc"") is False
    assert same_chars(""aabbcc"", ""aabbcc"") is True
    assert same_chars(""aabbcc"", ""aabbccd"") is False
    assert same_chars(""aabbcc"", ""aabbc"") is False
    assert same_chars(""aabbcc"", ""aabb"") is False
    assert same_chars(""aabbcc"", ""aab"") is False
    assert same_chars(""aabbcc"", ""aa"") is False
    assert same_chars(""aabbcc"", ""a"") is False
    assert same_chars(""aabbcc"", """") is False
    assert same_chars("""", ""aabbcc"") is False
    assert same_chars(""abcdef"", ""fedcba"") is True
    assert same_chars(""abcdef"", ""fedcba"") is True
    assert same_chars(""abcdef"", ""fedcb"") is False
    assert same_chars(""abcdef"", ""fedc"") is False
    assert same_chars(""abcdef"", ""fed"") is False
    assert same_chars(""abcdef",
fib,"def fib(n: int):
    """"""Return n-th Fibonacci number.""""""","

METADATA = {}


def check(candidate):
    assert candidate(10) == 55
    assert candidate(1) == 1
    assert candidate(8) == 21
    assert candidate(11) == 89
    assert candidate(12) == 144

","def fib(n: int):
    """"""Return n-th Fibonacci number.""""""
    if n <= 1:
        return n
    else:
        return fib(n - 1) + fib(n - 2)


def fib_iter(n: int):
    """"""Return n-th Fibonacci number iteratively.""""""
    if n <= 1:
        return n
    else:
        prev, curr = 0, 1
        for _ in range(2, n + 1):
            prev, curr = curr, prev + curr
        return curr


def fib_memo(n: int, memo: dict = {}):
    """"""Return n-th Fibonacci number with memoization.""""""
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    else:
        memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)
        return memo[n]


def fib_memo_iter(n: int):
    """"""Return n-th Fibonacci number iteratively with memoization.""""""
    if n <= 1:
        return n
    else:
        memo = {0: 0, 1: 1}
        prev, curr = 0, 1
        for i in range(2, n + 1):
            prev, curr = curr, prev + curr
            memo[i] = curr
        return curr


def fib_bottom_up(n: int):
    """"""Return n-th Fibonacci number using bottom-up dynamic programming.""""""
    if n <= 1:
        return n
    else:
        dp = [0] * (n + 1)
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]
        return dp[n]


def fib_bottom_up_const_space(n: int):
    """"""Return n-th Fibonacci number using bottom-up dynamic programming with constant space.""""""
",
correct_bracketing,"def correct_bracketing(brackets: str):
    """""" brackets is a string of ""<"" and "">"".
    return True if every opening bracket has a corresponding closing bracket.""""""","

METADATA = {}


def check(candidate):
    assert candidate(""<>"")
    assert candidate(""<<><>>"")
    assert candidate(""<><><<><>><>"")
    assert candidate(""<><><<<><><>><>><<><><<>>>"")
    assert not candidate(""<<<><>>>>"")
    assert not candidate(""><<>"")
    assert not candidate(""<"")
    assert not candidate(""<<<<"")
    assert not candidate("">"")
    assert not candidate(""<<>"")
    assert not candidate(""<><><<><>><>><<>"")
    assert not candidate(""<><><<><>><>>><>"")

","def correct_bracketing(brackets: str):
    """""" brackets is a string of ""<"" and "">"".
    return True if every opening bracket has a corresponding closing bracket.""""""
    stack = []
    for bracket in brackets:
        if bracket == ""<"":
            stack.append(""<"")
        elif bracket == "">"":
            if not stack:
                return False
            stack.pop()
    return not stack",
monotonic,"def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 2, 4, 10]) == True
    assert candidate([1, 2, 4, 20]) == True
    assert candidate([1, 20, 4, 10]) == False
    assert candidate([4, 1, 0, -10]) == True
    assert candidate([4, 1, 1, 0]) == True
    assert candidate([1, 2, 3, 2, 5, 60]) == False
    assert candidate([1, 2, 3, 4, 5, 60]) == True
    assert candidate([9, 9, 9, 9]) == True

","def monotonic(l: list):
    """"""Return True is list elements are monotonically increasing or decreasing.""""""
    return all(l[i] <= l[i + 1] for i in range(len(l) - 1)) or all(l[i] >= l[i + 1] for i in range(len(l) - 1))

# Test the function
print(monotonic([1, 2, 3, 4, 5]))  # Output: True
print(monotonic([5, 4, 3, 2, 1]))  # Output: True
print(monotonic([1, 2, 3, 2, 5]))  # Output: False
print(monotonic([1, 6, 5, 4, 3]))  # Output: False
print(monotonic([1, 2, 3, 5, 4]))  # Output: False
print(monotonic([5, 4, 3, 2, 1, 0]))  # Output: False
print(monotonic([1, 2, 3, 4, 5, 6]))  # Output: True
print(monotonic([6, 5, 4, 3, 2, 1]))  # Output: True
print(monotonic([1, 1, 1, 1, 1]))  # Output: True
print(monotonic([1]))  # Output: True
print(monotonic([]))  # Output: True
print(monotonic([5, 5, 5, 5, 5]))  # Output: True
print(monotonic([5, 5, 5, 5, 4]))  # Output: False
print(monotonic([5, 5, 5, 4, 4]))  # Output: False
print(monotonic([5, 5, 4, 4, 4]))  # Output: False
print(monotonic([5, 4, 4, 4, 4]))  # Output: False
print(monotonic([4, 4, 4, 4, 4]))  # Output: True
print(monotonic([4, 4, 4, 4, 5]))  #",
common,"def common(l1: list, l2: list):
    """"""Return sorted unique common elements for two lists.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]
    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]
    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]
    assert candidate([4, 3, 2, 8], []) == []

","def common(l1: list, l2: list):
    """"""Return sorted unique common elements for two lists.""""""
    return sorted(set(l1) & set(l2))


def test_common():
    assert common([1, 2, 3], [2, 3, 4]) == [2, 3]
    assert common([1, 2, 3], [4, 5, 6]) == []
    assert common([1, 1, 2, 3], [1, 2, 2, 3, 4]) == [1, 2, 3]
    assert common([1, 2, 3], [1, 2, 3, 4, 5]) == [1, 2, 3]
    assert common([1, 2, 3, 4, 5], [1, 2, 3]) == [1, 2, 3]
    assert common([1, 2, 3, 4, 5], [6, 7, 8]) == []
    assert common([1, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert common([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert common([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5]
    assert common([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert common([1, 2, 3, 4, 5, 6], [7, 8, 9]) == []
    assert common([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]) == [1, 2",
largest_prime_factor,"def largest_prime_factor(n: int):
    """"""Return the largest prime factor of n. Assume n > 1 and is not a prime.""""""","

METADATA = {}


def check(candidate):
    assert candidate(15) == 5
    assert candidate(27) == 3
    assert candidate(63) == 7
    assert candidate(330) == 11
    assert candidate(13195) == 29

","def largest_prime_factor(n: int):
    """"""Return the largest prime factor of n. Assume n > 1 and is not a prime.""""""
    factor = 2
    while factor * factor <= n:
        if n % factor == 0:
            n //= factor
        else:
            factor += 1
    return n

# Test the function with an example
number = 600851475143
largest_prime = largest_prime_factor(number)
print(largest_prime)",
sum_to_n,"def sum_to_n(n: int):
    """"""sum_to_n is a function that sums numbers from 1 to n.""""""","

METADATA = {}


def check(candidate):
    assert candidate(1) == 1
    assert candidate(6) == 21
    assert candidate(11) == 66
    assert candidate(30) == 465
    assert candidate(100) == 5050

","def sum_to_n(n: int):
    """"""sum_to_n is a function that sums numbers from 1 to n.""""""
    return n * (n + 1) // 2


def main():
    """"""main is the main function that runs the program.""""""
    n = 10
    result = sum_to_n(n)
    print(f""The sum of numbers from 1 to {n} is: {result}"")


if __name__ == ""__main__"":
    main()",
correct_bracketing,"def correct_bracketing(brackets: str):
    """""" brackets is a string of ""("" and "")"".
    return True if every opening bracket has a corresponding closing bracket.""""""","

METADATA = {}


def check(candidate):
    assert candidate(""()"")
    assert candidate(""(()())"")
    assert candidate(""()()(()())()"")
    assert candidate(""()()((()()())())(()()(()))"")
    assert not candidate(""((()())))"")
    assert not candidate("")(()"")
    assert not candidate(""("")
    assert not candidate(""(((("")
    assert not candidate("")"")
    assert not candidate(""(()"")
    assert not candidate(""()()(()())())(()"")
    assert not candidate(""()()(()())()))()"")

","def correct_bracketing(brackets: str):
    """""" brackets is a string of ""("" and "")"".
    return True if every opening bracket has a corresponding closing bracket.""""""
    stack = []
    for bracket in brackets:
        if bracket == ""("":
            stack.append(bracket)
        elif bracket == "")"":
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0

# Test cases
print(correct_bracketing(""()""))  # Output: True
print(correct_bracketing(""(())""))  # Output: True
print(correct_bracketing(""())""))  # Output: False
print(correct_bracketing(""((())""))  # Output: False
print(correct_bracketing(""(()""))  # Output: False
print(correct_bracketing(""""))  # Output: True
print(correct_bracketing(""((()))""))  # Output: True
print(correct_bracketing(""((())))()""))  # Output: False
print(correct_bracketing(""((()()())))()""))  # Output: False
print(correct_bracketing(""((()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()()()()()())))()""))  # Output: True
print(correct_bracketing(""((()()()()()()()()()()()()()",
derivative,"def derivative(xs: list):
    """""" xs represent coefficients of a polynomial.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     Return derivative of this polynomial in the same form.""""""","

METADATA = {}


def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]
    assert candidate([1, 2, 3]) == [2, 6]
    assert candidate([3, 2, 1]) == [2, 2]
    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]
    assert candidate([1]) == []

","def derivative(xs: list):
    """""" xs represent coefficients of a polynomial.
    xs[0] + xs[1] * x + xs[2] * x^2 + ....
     Return derivative of this polynomial in the same form.""""""
    if len(xs) == 0:
        return []
    return xs[1:] + [0] * (len(xs) - 1)


def derivative_test():
    assert derivative([1, 2, 3]) == [2, 6]
    assert derivative([1, 2, 3, 4]) == [2, 6, 12]
    assert derivative([1, 2, 3, 4, 5]) == [2, 6, 12, 20]
    assert derivative([1, 2, 3, 4, 5, 6]) == [2, 6, 12, 20, 30]
    assert derivative([1, 2, 3, 4, 5, 6, 7]) == [2, 6, 12, 20, 30, 42]
    assert derivative([1, 2, 3, 4, 5, 6, 7, 8]) == [2, 6, 12, 20, 30, 42, 56]
    assert derivative([1, 2, 3, 4, 5, 6, 7, 8, 9]) == [2, 6, 12, 20, 30, 42, 56, 72]
    assert derivative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [2, 6, 12, 20, 30, 42, 56, 72, 90]
    assert derivative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [2, 6, 12, 20, 30, 42, 56, 72, 90, 110]
    assert derivative([1, 2, 3, 4, 5, 6, 7, 8, 9, ",
fibfib,"def fibfib(n: int):
    """"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fibfib(0) == 0
    fibfib(1) == 0
    fibfib(2) == 1
    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
    Please write a function to efficiently compute the n-th element of the fibfib number sequence.""""""","

METADATA = {}


def check(candidate):
    assert candidate(2) == 1
    assert candidate(1) == 0
    assert candidate(5) == 4
    assert candidate(8) == 24
    assert candidate(10) == 81
    assert candidate(12) == 274
    assert candidate(14) == 927

","def fibfib(n: int):
    """"""The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fibfib(0) == 0
    fibfib(1) == 0
    fibfib(2) == 1
    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).
    Please write a function to efficiently compute the n-th element of the fibfib number sequence.""""""

    if n == 0:
        return 0
    elif n == 1:
        return 0
    elif n == 2:
        return 1
    else:
        a, b, c = 0, 0, 1
        for _ in range(3, n + 1):
            a, b, c = b, c, a + b + c
        return c

# Test the function with some sample inputs
print(fibfib(0))  # Output: 0
print(fibfib(1))  # Output: 0
print(fibfib(2))  # Output: 1
print(fibfib(5))  # Output: 2
print(fibfib(10))  # Output: 12
print(fibfib(20))  # Output: 17711
print(fibfib(30))  # Output: 1346269
print(fibfib(40))  # Output: 2777789
print(fibfib(50))  # Output: 1548008755920
print(fibfib(100))  # Output: 2577997503093631332851435330135411988077732883754320227562303449754785017205229037726558607385895638280714575848404968381042587878451048000000000000000000000000000000000000000000000000000000000000000000000000000000000",
vowels_count,"FIX = """"""
Add more test cases.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:""""""","def check(candidate):

    # Check some simple cases
    assert candidate(""abcde"") == 2, ""Test 1""
    assert candidate(""Alone"") == 3, ""Test 2""
    assert candidate(""key"") == 2, ""Test 3""
    assert candidate(""bye"") == 1, ""Test 4""
    assert candidate(""keY"") == 2, ""Test 5""
    assert candidate(""bYe"") == 1, ""Test 6""
    assert candidate(""ACEDY"") == 3, ""Test 7""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""

","FIX = """"""
Add more test cases.
""""""

def vowels_count(s):
    """"""Write a function vowels_count which takes a string representing
    a word as input and returns the number of vowels in the string.
    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a
    vowel, but only when it is at the end of the given word.

    Example:""""""
    return sum(1 for char in s if char.lower() in 'aeiou')

# Test cases
def test_vowels_count():
    assert vowels_count(""apple"") == 2
    assert vowels_count(""hello"") == 2
    assert vowels_count(""why"") == 0
    assert vowels_count(""yummy"") == 2
    assert vowels_count(""python"") == 2
    assert vowels_count(""aeiou"") == 5
    assert vowels_count(""why not"") == 3
    assert vowels_count("""") == 0

test_vowels_count()",
circular_shift,"def circular_shift(x, shift):
    """"""Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.""""""","def check(candidate):

    # Check some simple cases
    assert candidate(100, 2) == ""001""
    assert candidate(12, 2) == ""12""
    assert candidate(97, 8) == ""79""
    assert candidate(12, 1) == ""21"", ""This prints if this assert fails 1 (good for debugging!)""

    # Check some edge cases that are easy to work out by hand.
    assert candidate(11, 101) == ""11"", ""This prints if this assert fails 2 (also good for debugging!)""

","def circular_shift(x, shift):
    """"""Circular shift the digits of the integer x, shift the digits right by shift
    and return the result as a string.
    If shift > number of digits, return digits reversed.""""""
    digits = [int(d) for d in str(x)]
    if shift > len(digits):
        return ''.join(str(d) for d in reversed(digits))
    else:
        return ''.join(str(d) for d in digits[-shift:] + digits[:-shift])

# Test the function with the example provided in the code snippet
x = 123456
shift = 2
result = circular_shift(x, shift)
print(result)  # Output: ""561234""

# Test the function with a different input
x = 789
shift = 3
result = circular_shift(x, shift)
print(result)  # Output: ""978""

# Test the function with a shift greater than the number of digits
x = 100
shift = 4
result = circular_shift(x, shift)
print(result)  # Output: ""01""

# Test the function with a shift of 0
x = 123456
shift = 0
result = circular_shift(x, shift)
print(result)  # Output: ""123456""

# Test the function with a shift that results in no change
x = 123456
shift = 6
result = circular_shift(x, shift)
print(result)  # Output: ""123456""

# Test the function with a shift that results in all digits being the same
x = 111111
shift = 3
result = circular_shift(x, shift)
print(result)  # Output: ""111111""

# Test the function with a shift that results in all digits being reversed
x = 123456
shift = 6
result = circular_shift(x, shift)
print(result)  # Output: ""654321""

# Test the function with a shift that results in all digits being reversed
x = 123456
shift = 7
result = circular_shift(x, shift)
print(result)  # Output: ""65432",
digitSum,"
def digitSum(s):
    """"""Task
    Write a function that takes a string as input and returns the sum of the upper characters only'
    ASCII codes.

    Examples:
        digitSum("""") => 0
        digitSum(""abAB"") => 131
        digitSum(""abcCd"") => 67
        digitSum(""helloE"") => 69
        digitSum(""woArBld"") => 131
        digitSum(""aAaaaXa"") => 153
    """"""
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate("""") == 0, ""Error""
    assert candidate(""abAB"") == 131, ""Error""
    assert candidate(""abcCd"") == 67, ""Error""
    assert candidate(""helloE"") == 69, ""Error""
    assert candidate(""woArBld"") == 131, ""Error""
    assert candidate(""aAaaaXa"") == 153, ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate("" How are yOu?"") == 151, ""Error""
    assert candidate(""You arE Very Smart"") == 327, ""Error""

","
def digitSum(s):
    """"""Task
    Write a function that takes a string as input and returns the sum of the upper characters only'
    ASCII codes.

    Examples:
        digitSum("""") => 0
        digitSum(""abAB"") => 131
        digitSum(""abcCd"") => 67
        digitSum(""helloE"") => 69
        digitSum(""woArBld"") => 131
        digitSum(""aAaaaXa"") => 153
    """"""
    return sum(ord(c) for c in s if c.isupper())


def test_digitSum():
    assert digitSum("""") == 0
    assert digitSum(""abAB"") == 131
    assert digitSum(""abcCd"") == 67
    assert digitSum(""helloE"") == 69
    assert digitSum(""woArBld"") == 131
    assert digitSum(""aAaaaXa"") == 153


if __name__ == ""__main__"":
    test_digitSum()",
fruit_distribution,"
def fruit_distribution(s,n):
    """"""
    In this task, you will be given a string that represents a number of apples and oranges 
    that are distributed in a basket of fruit this basket contains 
    apples, oranges, and mango fruits. Given the string that represents the total number of 
    the oranges and apples and an integer that represent the total number of the fruits 
    in the basket return the number of the mango fruits in the basket.
    for examble:
    fruit_distribution(""5 apples and 6 oranges"", 19) ->19 - 5 - 6 = 8
    fruit_distribution(""0 apples and 1 oranges"",3) -> 3 - 0 - 1 = 2
    fruit_distribution(""2 apples and 3 oranges"", 100) -> 100 - 2 - 3 = 95
    fruit_distribution(""100 apples and 1 oranges"",120) -> 120 - 100 - 1 = 19
    """"""
","def check(candidate):

    # Check some simple cases
    assert candidate(""5 apples and 6 oranges"",19) == 8
    assert candidate(""5 apples and 6 oranges"",21) == 10
    assert candidate(""0 apples and 1 oranges"",3) == 2
    assert candidate(""1 apples and 0 oranges"",3) == 2
    assert candidate(""2 apples and 3 oranges"",100) == 95
    assert candidate(""2 apples and 3 oranges"",5) == 0
    assert candidate(""1 apples and 100 oranges"",120) == 19
","
def fruit_distribution(s,n):
    """"""
    In this task, you will be given a string that represents a number of apples and oranges 
    that are distributed in a basket of fruit this basket contains 
    apples, oranges, and mango fruits. Given the string that represents the total number of 
    the oranges and apples and an integer that represent the total number of the fruits 
    in the basket return the number of the mango fruits in the basket.
    for examble:
    fruit_distribution(""5 apples and 6 oranges"", 19) ->19 - 5 - 6 = 8
    fruit_distribution(""0 apples and 1 oranges"",3) -> 3 - 0 - 1 = 2
    fruit_distribution(""2 apples and 3 oranges"", 100) -> 100 - 2 - 3 = 95
    fruit_distribution(""100 apples and 1 oranges"",120) -> 120 - 100 - 1 = 19
    """"""
    # Extract the number of apples and oranges from the input string
    apples = int(s.split()[0])
    oranges = int(s.split()[-2])
    
    # Calculate the number of mangoes in the basket
    mangoes = n - apples - oranges
    
    return mangoes

# Test cases
print(fruit_distribution(""5 apples and 6 oranges"", 19))  # Output: 8
print(fruit_distribution(""0 apples and 1 oranges"", 3))   # Output: 2
print(fruit_distribution(""2 apples and 3 oranges"", 100)) # Output: 95
print(fruit_distribution(""100 apples and 1 oranges"", 120)) # Output: 19
",
pluck,"
def pluck(arr):
    """"""
    ""Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].

    Example 1:
        Input: [4,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index.

    Example 2:
        Input: [1,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index. 

    Example 3:
        Input: []
        Output: []
    
    Example 4:
        Input: [5, 0, 3, 0, 4, 2]
        Output: [0, 1]
        Explanation: 0 is the smallest value, but  there are two zeros,
                     so we will choose the first zero, which has the smallest index.

    Constraints:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value
    """"""
","def check(candidate):

    # Check some simple cases
    assert True, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate([4,2,3]) == [2, 1], ""Error""
    assert candidate([1,2,3]) == [2, 1], ""Error""
    assert candidate([]) == [], ""Error""
    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], ""Error""

    # Check some edge cases that are easy to work out by hand.
    assert True, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], ""Error""
    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], ""Error""
    assert candidate([7, 6, 7, 1]) == [6, 1], ""Error""
    assert candidate([7, 9, 7, 1]) == [], ""Error""

","
def pluck(arr):
    """"""
    ""Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].

    Example 1:
        Input: [4,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index.

    Example 2:
        Input: [1,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index. 

    Example 3:
        Input: []
        Output: []
    
    Example 4:
        Input: [5, 0, 3, 0, 4, 2]
        Output: [0, 1]
        Explanation: 0 is the smallest value, but  there are two zeros,
                     so we will choose the first zero, which has the smallest index.

    Constraints:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value
    """"""
    if not arr:
        return []

    even_values = [(val, idx) for idx, val in enumerate(arr) if val % 2 == 0]
    
    if not even_values:
        return []

    min_even_value = min(even_values, key=lambda x: x[0])
    min_index = min(idx for val, idx in even_values if val == min_even_value[0])
    
    return [min_even_value[0], min_index]

# Test cases
print(pluck([4, 2, 3]))  # Output: [2, 1]
print(pluck([1, 2, 3]))  # Output: [2, 1]
print(pluck([]))         # Output: []
print(pluck([5, 0, 3, 0, 4, 2]))  # Output: [0, 1]
",
search,"
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
","def check(candidate):

    # manually generated tests
    assert candidate([5, 5, 5, 5, 1]) == 1
    assert candidate([4, 1, 4, 1, 4, 4]) == 4
    assert candidate([3, 3]) == -1
    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8
    assert candidate([2, 3, 3, 2, 2]) == 2

    # automatically generated tests
    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1
    assert candidate([3, 2, 8, 2]) == 2
    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1
    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1
    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1
    assert candidate([1, 9, 10, 1, 3]) == 1
    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5
    assert candidate([1]) == 1
    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4
    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2
    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1
    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4
    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4
    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2
    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1
    assert candidate([10]) == -1
    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2
    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1
    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1
    assert candidate([3, 10, 10, 9, 2]) == -1

","
def search(lst):
    '''
    You are given a non-empty list of positive integers. Return the greatest integer that is greater than 
    zero, and has a frequency greater than or equal to the value of the integer itself. 
    The frequency of an integer is the number of times it appears in the list.
    If no such a value exist, return -1.
    Examples:
        search([4, 1, 2, 2, 3, 1]) == 2
        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3
        search([5, 5, 4, 4, 4]) == -1
    '''
    freq_dict = {}
    for num in lst:
        if num in freq_dict:
            freq_dict[num] += 1
        else:
            freq_dict[num] = 1
    
    for num in sorted(freq_dict.keys(), reverse=True):
        if num > 0 and freq_dict[num] >= num:
            return num
    
    return -1

# Test cases
print(search([4, 1, 2, 2, 3, 1]))  # Output: 2
print(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))  # Output: 3
print(search([5, 5, 4, 4, 4]))  # Output: -1
",
strange_sort_list,"
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
","def check(candidate):

    # Check some simple cases
    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]
    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]
    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]
    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert candidate([]) == []
    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]
    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]
    assert candidate([111111]) == [111111]

    # Check some edge cases that are easy to work out by hand.
    assert True

","
def strange_sort_list(lst):
    '''
    Given list of integers, return list in strange order.
    Strange sorting, is when you start with the minimum value,
    then maximum of the remaining integers, then minimum and so on.

    Examples:
    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    strange_sort_list([]) == []
    '''
    if not lst:
        return []

    sorted_lst = sorted(lst)
    result = []
    start = 0
    end = len(sorted_lst) - 1

    while start <= end:
        result.append(sorted_lst[start])
        start += 1
        if start <= end:
            result.append(sorted_lst[end])
            end -= 1

    return result


def test_strange_sort_list():
    assert strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]
    assert strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]
    assert strange_sort_list([]) == []


if __name__ == ""__main__"":
    test_strange_sort_list()",
triangle_area,"
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
","def check(candidate):

    # Check some simple cases
    assert candidate(3, 4, 5) == 6.00, ""This prints if this assert fails 1 (good for debugging!)""
    assert candidate(1, 2, 10) == -1
    assert candidate(4, 8, 5) == 8.18
    assert candidate(2, 2, 2) == 1.73
    assert candidate(1, 2, 3) == -1
    assert candidate(10, 5, 7) == 16.25
    assert candidate(2, 6, 3) == -1

    # Check some edge cases that are easy to work out by hand.
    assert candidate(1, 1, 1) == 0.43, ""This prints if this assert fails 2 (also good for debugging!)""
    assert candidate(2, 2, 10) == -1

","
def triangle_area(a, b, c):
    '''
    Given the lengths of the three sides of a triangle. Return the area of
    the triangle rounded to 2 decimal points if the three sides form a valid triangle. 
    Otherwise return -1
    Three sides make a valid triangle when the sum of any two sides is greater 
    than the third side.
    Example:
    triangle_area(3, 4, 5) == 6.00
    triangle_area(1, 2, 10) == -1
    '''
    if a + b > c and a + c > b and b + c > a:
        s = (a + b + c) / 2
        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5
        return round(area, 2)
    else:
        return -1


def test_triangle_area():
    assert triangle_area(3, 4, 5) == 6.00
    assert triangle_area(1, 2, 10) == -1
    assert triangle_area(5, 5, 5) == 10.83
    assert triangle_area(3, 3, 3) == 3.89
    assert triangle_area(1, 1, 1) == 0.43
    assert triangle_area(2, 2, 2) == 1.73
    assert triangle_area(3, 3, 4) == 3.89
    assert triangle_area(3, 4, 3) == 3.89
    assert triangle_area(4, 3, 3) == 3.89
    assert triangle_area(1, 2, 2) == 0.97
    assert triangle_area(2, 1, 2) == 0.97
    assert triangle_area(2, 2, 1) == 0.97
    assert triangle_area(1, 2, 3) == 0.97
    assert triangle_area(2, 1, 3) == 0.97
    assert triangle_area(2, 3, 1) == 0.97
    assert triangle_area(1, 3, 2) == 0.97
    assert triangle_area(3, 1, 2) == 0.97
    assert triangle_area(3, 2, 1) == 0.97
    assert triangle_area(1, 1, 2) == 0.43
    assert triangle_area(1, 2, 1) == 0.43
    assert triangle_area(2, 1, 1) == 0.43",
