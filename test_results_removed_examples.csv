entry_point,formatted_prompt,test_cases,generated_code,all_tests_passed
has_close_elements,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

","from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.""""""
    numbers.sort()
    for i in range(len(numbers) - 1):
        if numbers[i + 1] - numbers[i] <= threshold:
            return True
    return False


# Test cases
print(has_close_elements([1, 2, 3, 4, 5], 2.0))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 0.5))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 1.5))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 1.0))  # Output: True
print(has_close_elements([1, 2, 3, 4, 5], 0.0))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.1))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.01))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.0001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.00001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.000001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.0000001))  # Output: False
print(has_close_elements([1, 2, 3, 4, 5], 0.00000001))  # Output: False
print",
separate_paren_groups,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
","from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.""""""
    result = []
    current_group = """"
    stack = []

    for char in paren_string:
        if char == '(':
            stack.append('(')
            current_group += char
        elif char == ')':
            if stack:
                stack.pop()
                current_group += char
                if not stack:
                    result.append(current_group)
                    current_group = """"
            else:
                current_group += char
        else:
            current_group += char

    return result


# Test the function with an example
input_string = ""((A+B)*(C-D))/(E+F)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)']

# Test the function with another example
input_string = ""((A+B)*C)-D""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*C)', 'D']

# Test the function with a nested parentheses example
input_string = ""((A+B)*(C-D))/(E+F)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)']

# Test the function with a string containing multiple groups
input_string = ""((A+B)*(C-D))/(E+F)/(G+H)""
output = separate_paren_groups(input_string)
print(output)  # Output: ['((A+B)*(C-D))', '(E+F)', '(G+H)']
",
truncate_number,"def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
","def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.""""""
    return number % 1


def test_truncate_number():
    assert truncate_number(3.14159) == 0.14159
    assert truncate_number(1.23456) == 0.23456
    assert truncate_number(5.0) == 0.0
    assert truncate_number(10.98765) == 0.98765
    assert truncate_number(0.0001) == 0.0001
    assert truncate_number(99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
below_zero,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
","from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.""""""

    balance = 0
    for operation in operations:
        balance += operation
        if balance < 0:
            return True
    return False


# Test cases
print(below_zero([100, -50, 20, -30]))  # Output: True
print(below_zero([50, 20, 30, 40]))     # Output: False
print(below_zero([-10, 20, -30, 40]))    # Output: True
print(below_zero([10, -20, 30, -40]))    # Output: True
print(below_zero([10, 20, 30, 40]))      # Output: False
",
mean_absolute_deviation,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

","from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |""""""
    if not numbers:
        return 0.0

    mean = sum(numbers) / len(numbers)
    deviations = [abs(num - mean) for num in numbers]
    mad = sum(deviations) / len(deviations)
    return mad


def test_mean_absolute_deviation():
    assert mean_absolute_deviation([1, 2, 3, 4, 5]) == 1.5
    assert mean_absolute_deviation([1, 2, 3, 10, 11]) == 4.0
    assert mean_absolute_deviation([1, 2, 3, 4, 100]) == 50.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2.5
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100]) == 25.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000]) == 250.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 10000]) == 2500.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 10000, 100000]) == 25000.0
    assert mean_absolute_deviation([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100,",
intersperse,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
","from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'""""""
    return [numbers[i] if i % 2 == 0 else delimeter for i in range(len(numbers) * 2 - 1)]


if __name__ == '__main__':
    numbers = [1, 2, 3, 4, 5]
    delimeter = 0
    result = intersperse(numbers, delimeter)
    print(result)",
parse_nested_parens,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
","from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.""""""
    result = []
    for group in paren_string.split():
        stack = []
        max_depth = 0
        for char in group:
            if char == '(':
                stack.append('(')
                max_depth = max(max_depth, len(stack))
            elif char == ')':
                if stack:
                    stack.pop()
        result.append(max_depth)
    return result


# Test the function with the provided example
paren_string = ""() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()",
filter_by_substring,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
","from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring""""""
    return [s for s in strings if substring in s]


# Test the function
input_strings = [""apple"", ""banana"", ""orange"", ""grape"", ""kiwi""]
substring_to_filter = ""a""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['apple', 'banana', 'orange', 'grape', 'kiwi']

substring_to_filter = ""an""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['apple', 'banana', 'orange', 'grape', 'kiwi']

substring_to_filter = ""gr""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: ['grape']

substring_to_filter = ""pear""
filtered_strings = filter_by_substring(input_strings, substring_to_filter)
print(filtered_strings)  # Output: []
",
sum_product,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
","from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.""""""
    sum_result = 0
    product_result = 1

    for num in numbers:
        sum_result += num
        product_result *= num

    return sum_result, product_result


# Test the function with an example
numbers = [2, 3, 4]
sum_result, product_result = sum_product(numbers)
print(f""Sum of numbers: {sum_result}"")
print(f""Product of numbers: {product_result}"")",
rolling_max,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
","from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.""""""
    rolling_max_list = []
    max_element = float('-inf')

    for num in numbers:
        max_element = max(max_element, num)
        rolling_max_list.append(max_element)

    return rolling_max_list


def max_subarray_sum(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len(numbers)):
        current_sum += numbers[i]

        if i >= k - 1:
            max_sum = max(max_sum, current_sum)
            current_sum -= numbers[i - (k - 1)]
            start_index = i - (k - 1)

    return max_sum, start_index


def max_subarray_sum_sliding_window(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers using sliding window technique.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len(numbers)):
        current_sum += numbers[i]

        if i >= k:
            current_sum -= numbers[i - k]

        if i >= k - 1:
            max_sum = max(max_sum, current_sum)
            start_index = i - (k - 1)

    return max_sum, start_index


def max_subarray_sum_rolling_window(numbers: List[int], k: int) -> Tuple[int, int]:
    """""" Find the maximum sum of a subarray of size k in a given list of integers using rolling window technique.""""""
    max_sum = float('-inf')
    current_sum = 0
    start_index = 0

    for i in range(len",
make_palindrome,"def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
","def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.""""""
    if is_palindrome(string):
        return string
    for i in range(len(string) // 2, len(string)):
        if is_palindrome(string[i:]):
            return string[i:][::-1] + string


def test_make_palindrome():
    assert make_palindrome(""abcd"") == ""dcba""
    assert make_palindrome(""abba"") == ""abba""
    assert make_palindrome(""a"") == ""a""
    assert make_palindrome(""aa"") == ""aa""
    assert make_palindrome(""aaa"") == ""aaa""
    assert make_palindrome(""aaaa"") == ""aaaa""
    assert make_palindrome(""abccba"") == ""abccba""
    assert make_palindrome(""abcba"") == ""abcba""
    assert make_palindrome(""abbaa"") == ""abbaa""
    assert make_palindrome(""abbba"") == ""abbba""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbaa"") == ""abbaa""
    assert make_palindrome(""abbba"") == ""abbba""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
    assert make_palindrome(""abbab"") == ""babab""
",
string_xor,"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
","from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.""""""
    return ''.join([str(int(x) ^ int(y)) for x, y in zip(a, b)])


def string_to_bits(s: str) -> List[str]:
    """""" Convert a string to a list of bits. """"""
    return [bin(ord(x))[2:].zfill(8) for x in s]


def bits_to_string(bits: List[str]) -> str:
    """""" Convert a list of bits to a string. """"""
    return ''.join([chr(int(x, 2)) for x in bits])


def main():
    a = ""10101010""
    b = ""01010101""
    print(string_xor(a, b))  # Output: ""11111111""

    message = ""Hello, World!""
    bits = string_to_bits(message)
    print(bits)
    decoded_message = bits_to_string(bits)
    print(decoded_message)


if __name__ == ""__main__"":
    main()",
longest,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
","from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.""""""
    if not strings:
        return None
    return max(strings, key=len)


def test_longest():
    assert longest([""abc"", ""def"", ""ghi""]) == ""abc""
    assert longest([""abc"", ""def"", ""xyz""]) == ""def""
    assert longest([""abc"", ""def"", ""xyz"", ""pqrstuv""]) == ""pqrstuv""
    assert longest([]) is None
    assert longest([""a""]) == ""a""
    assert longest([""abc"", ""def"", ""xyz"", ""a""]) == ""abc""",
greatest_common_divisor,"def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
","def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b""""""
    while a!= 0 and b!= 0:
        if a > b:
            a %= b
        else:
            b %= a
    return a + b


def least_common_multiple(a: int, b: int) -> int:
    """""" Return a least common multiple of two integers a and b""""""
    return abs(a * b) // greatest_common_divisor(a, b)


def main():
    a, b = map(int, input().split())
    print(greatest_common_divisor(a, b))
    print(least_common_multiple(a, b))


if __name__ == ""__main__"":
    main()",
all_prefixes,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
","from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string""""""
    return [string[:i] for i in range(1, len(string) + 1)]


def all_suffixes(string: str) -> List[str]:
    """""" Return list of all suffixes from shortest to longest of the input string""""""
    return [string[i:] for i in range(len(string))]


def all_substrings(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_2(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_3(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_4(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_5(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_6(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string""""""
    return [string[i:j] for i in range(len(string)) for",
string_sequence,"def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
","def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.""""""
    return''.join(str(i) for i in range(n+1))

# Test the function with n = 5
n = 5
result = string_sequence(n)
print(result)",
count_distinct_characters,"def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
","def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of""""""
    distinct_chars = set()
    for char in string:
        if char.isalpha():
            distinct_chars.add(char.lower())
    return len(distinct_chars)


# Test the function
test_string = ""Hello, World!""
print(count_distinct_characters(test_string))  # Output: 7 (Including space and comma)

test_string = ""Python is AWESOME""
print(count_distinct_characters(test_string))  # Output: 10 (Including space and case)

test_string = ""1234567890""
print(count_distinct_characters(test_string))  # Output: 10 (All digits are distinct)

test_string = ""Same Same but different""
print(count_distinct_characters(test_string))  # Output: 13 (Including space and case)",
parse_music,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
","from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat""""""
    music_dict = {'o': 4, 'o|': 2, '.|': 1}
    music_list = [music_dict[note] for note in music_string if note in music_dict]
    return music_list


# Test the function with an example
music_string = ""o.|o|o.|""
parsed_music = parse_music(music_string)
print(parsed_music)  # Output: [4, 1, 2, 4, 1]

# Test the function with another example
music_string = ""o|.|o.|.|""
parsed_music = parse_music(music_string)
print(parsed_music)  # Output: [2, 1, 4, 1, 1]
",
how_many_times,"def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
","def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.""""""
    count = 0
    start_index = 0
    while start_index < len(string):
        found_index = string.find(substring, start_index)
        if found_index == -1:
            break
        count += 1
        start_index = found_index + 1
    return count

# Test the function
original_string = ""banana""
sub_string = ""na""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""apple""
sub_string = ""le""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""iss""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""hello world""
sub_string = ""l""
print(how_many_times(original_string, sub_string))  # Output: 3

original_string = ""aaaaa""
sub_string = ""aa""
print(how_many_times(original_string, sub_string))  # Output: 4

original_string = ""mississippi""
sub_string = ""pi""
print(how_many_times(original_string, sub_string))  # Output: 2

original_string = ""mississippi""
sub_string = ""issip""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""issipi""
print(how_many_times(original_string, sub_string))  # Output: 0

original_string = ""mississippi""
sub_string = ""mississippi""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""mississippi""
print(how_many_times(original_string, sub_string))  # Output: 1

original_string = ""mississippi""
sub_string = ""mississippi""
print(",
sort_numbers,"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
","from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest""""""
    number_dict = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }

    numbers_list = numbers.split()
    sorted_numbers = sorted(numbers_list, key=lambda x: number_dict[x])

    return''.join(sorted_numbers)


# Test the function
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort_numbers(""nine five zero two three""))  # Output: zero two three five nine
print(sort",
find_closest_elements,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

","from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).""""""
    numbers.sort()
    min_diff = numbers[1] - numbers[0]
    closest_pair = (numbers[0], numbers[1])

    for i in range(1, len(numbers) - 1):
        diff = numbers[i + 1] - numbers[i]
        if diff < min_diff:
            min_diff = diff
            closest_pair = (numbers[i], numbers[i + 1])

    return closest_pair


# Test the function
numbers = [1.5, 10.5, 12.3, 5.8, 7.2, 9.1]
closest_pair = find_closest_elements(numbers)
print(f""The closest pair of numbers are: {closest_pair[0]} and {closest_pair[1]}"")",
rescale_to_unit,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
","from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1""""""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) for num in numbers]


def rescale_to_unit_interval(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1,
    but the interval between 0 and 1 will be the same as the original interval""""""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) * (1 - 0) + 0 for num in numbers]",
filter_integers,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
","from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers""""""
    return [value for value in values if isinstance(value, int)]


def filter_strings(values: List[Any]) -> List[str]:
    """""" Filter given list of any python values only for strings""""""
    return [value for value in values if isinstance(value, str)]


def filter_floats(values: List[Any]) -> List[float]:
    """""" Filter given list of any python values only for floats""""""
    return [value for value in values if isinstance(value, float)]


def filter_dicts(values: List[Any]) -> List[dict]:
    """""" Filter given list of any python values only for dicts""""""
    return [value for value in values if isinstance(value, dict)]


def filter_lists(values: List[Any]) -> List[list]:
    """""" Filter given list of any python values only for lists""""""
    return [value for value in values if isinstance(value, list)]


def filter_tuples(values: List[Any]) -> List[tuple]:
    """""" Filter given list of any python values only for tuples""""""
    return [value for value in values if isinstance(value, tuple)]


def filter_sets(values: List[Any]) -> List[set]:
    """""" Filter given list of any python values only for sets""""""
    return [value for value in values if isinstance(value, set)]


def filter_none(values: List[Any]) -> List[None]:
    """""" Filter given list of any python values only for None""""""
    return [value for value in values if value is None]


def filter_bools(values: List[Any]) -> List[bool]:
    """""" Filter given list of any python values only for bools""""""
    return [value for value in values if isinstance(value, bool)]


def filter_functions(values: List[Any]) -> List[Any]:
    """""" Filter given list of any python values only for functions""""""
    return [value for value in values if callable(value)]


def filter_classes(values: List[Any]) -> List[Any]:
    """""" Filter given list of any python values",
strlen,"def strlen(string: str) -> int:
    """""" Return length of given string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
","def strlen(string: str) -> int:
    """""" Return length of given string""""""
    return len(string)


def str_reverse(string: str) -> str:
    """""" Return reversed string""""""
    return string[::-1]


def str_upper(string: str) -> str:
    """""" Return uppercase string""""""
    return string.upper()


def str_lower(string: str) -> str:
    """""" Return lowercase string""""""
    return string.lower()


def str_capitalize(string: str) -> str:
    """""" Return capitalized string""""""
    return string.capitalize()


def str_title(string: str) -> str:
    """""" Return title case string""""""
    return string.title()


def str_swapcase(string: str) -> str:
    """""" Return swapped case string""""""
    return string.swapcase()


def str_replace(string: str, old: str, new: str) -> str:
    """""" Return string with old replaced by new""""""
    return string.replace(old, new)


def str_split(string: str, sep: str) -> list:
    """""" Return list of strings split by separator""""""
    return string.split(sep)


def str_join(strings: list, sep: str) -> str:
    """""" Return string joined by separator""""""
    return sep.join(strings)


def str_strip(string: str, chars: str) -> str:
    """""" Return string with leading and trailing characters removed""""""
    return string.strip(chars)


def str_lstrip(string: str, chars: str) -> str:
    """""" Return string with leading characters removed""""""
    return string.lstrip(chars)


def str_rstrip(string: str, chars: str) -> str:
    """""" Return string with trailing characters removed""""""
    return string.rstrip(chars)


def str_center(string: str, width: int, fillchar: str) -> str:
    """""" Return string centered in a string of given width""""""
    return string.center(width, fillchar)

",
largest_divisor,"def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
","def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n""""""
    for i in range(n-1, 0, -1):
        if n % i == 0:
            return i


def smallest_multiple(n: int) -> int:
    """""" For a given number n, find the smallest number that is a multiple of n""""""
    i = n
    while True:
        if i % 2 == 0 and i % 3 == 0 and i % 4 == 0 and i % 5 == 0 and i % 6 == 0 and i % 7 == 0 and i % 8 == 0 and i % 9 == 0:
            return i
        i += n


def sum_of_multiples(n: int) -> int:
    """""" For a given number n, find the sum of all multiples of n below 1000""""""
    total_sum = 0
    for i in range(n, 1000, n):
        total_sum += i
    return total_sum


def sum_of_even_fibonacci(n: int) -> int:
    """""" For a given number n, find the sum of all even-valued terms in the Fibonacci sequence below n""""""
    fib_sequence = [1, 2]
    while fib_sequence[-1] + fib_sequence[-2] < n:
        fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])

    even_sum = sum(num for num in fib_sequence if num % 2 == 0)
    return even_sum


def largest_palindrome_product(n: int) -> int:
    """""" For a given number n, find the largest palindrome made from the product of two n-digit numbers""""""
    largest_palindrome = 0
    for i in range(10**(n-1), 10**n):
        for j in range(10**(n-1), 10**n):
            product = i * j
            if str(product) == str(product)[::-1] and product > largest_palindrome:
                largest_palindrome = product
    return largest_palindrome


",
factorize,"from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
","from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors""""""
    factors = []
    divisor = 2
    while n > 1:
        if n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        else:
            divisor += 1
    return factors


def test_factorize():
    assert factorize(1) == [1]
    assert factorize(2) == [2]
    assert factorize(3) == [3]
    assert factorize(4) == [2, 2]
    assert factorize(5) == [5]
    assert factorize(6) == [2, 3]
    assert factorize(7) == [7]
    assert factorize(8) == [2, 2, 2]
    assert factorize(9) == [3, 3]
    assert factorize(10) == [2, 5]
    assert factorize(11) == [11]
    assert factorize(12) == [2, 2, 3]
    assert factorize(13) == [13]
    assert factorize(14) == [2, 7]
    assert factorize(15) == [3, 5]
    assert factorize(16) == [2, 2, 2, 2]
    assert factorize(17) == [17]
    assert factorize(18) == [2, 3, 3]
    assert factorize(19) == [19]
    assert factorize(20) == [2, 2, 5]
    assert factorize(21) == [3, 7]
    assert factorize(22) == [2, 11]
    assert factorize(23) == [23]
    assert factorize(24) == [2, 2, 2, 3]
    assert factorize(25) == [5, 5]
    assert factorize(26) == [2, 13]
    assert factorize(27) == [3, 3, 3]
    assert factorize(28) == [2, 2, 7",
remove_duplicates,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
","from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.""""""
    unique_numbers = []
    for num in numbers:
        if num not in unique_numbers:
            unique_numbers.append(num)
    return unique_numbers


def test_remove_duplicates():
    assert remove_duplicates([1, 2, 3, 1, 2, 3]) == [1, 2, 3]
    assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 1, 1, 1, 1]) == [1]
    assert remove_duplicates([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert remove_duplicates([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) == [1, 2, 3, 4, 5]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert remove_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1,",
flip_case,"def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
","def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.""""""
    return string.swapcase()


def test_flip_case():
    assert flip_case(""Hello, World!"") == ""hELLO, wORLD!""
    assert flip_case(""12345"") == ""12345""
    assert flip_case(""Python is AWESOME!"") == ""pYTHON IS awesome!""
    assert flip_case("""") == """"
    assert flip_case(""a"") == ""A""
    assert flip_case(""A"") == ""a""
    assert flip_case(""PyThOn"") == ""pYtHoN""",
concatenate,"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
","from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string""""""
    return """".join(strings)


def main():
    strings = [""Hello"", "" "", ""World"", ""!"", ""\n""]
    concatenated_string = concatenate(strings)
    print(concatenated_string)


if __name__ == ""__main__"":
    main()",
filter_by_prefix,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.""""""","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
","from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.""""""
    return [s for s in strings if s.startswith(prefix)]


def filter_by_suffix(strings: List[str], suffix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that end with a given suffix.""""""
    return [s for s in strings if s.endswith(suffix)]


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain a given substring.""""""
    return [s for s in strings if substring in s]


def filter_by_length(strings: List[str], length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a given length.""""""
    return [s for s in strings if len(s) == length]


def filter_by_min_length(strings: List[str], min_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length greater than or equal to a given minimum length.""""""
    return [s for s in strings if len(s) >= min_length]


def filter_by_max_length(strings: List[str], max_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length less than or equal to a given maximum length.""""""
    return [s for s in strings if len(s) <= max_length]


def filter_by_range_length(strings: List[str], min_length: int, max_length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a length within a given range.""""""
    return [s for s in strings if min_length <= len(s) <= max_length]


def filter_by_pattern(strings: List[str], pattern: str) -> List[str]:
    """""" Filter an input list of strings only for ones that match a given pattern.""""""
    return [s for s in strings if pattern in s]


def filter_by_contains_all(strings: List[str],",
get_positive,"def get_positive(l: list):
    """"""Return only positive numbers in the list.""""""","

METADATA = {}


def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

","def get_positive(l: list):
    """"""Return only positive numbers in the list.""""""
    return [num for num in l if num > 0]


def test_get_positive():
    assert get_positive([1, -2, 3, -4, 5]) == [1, 3, 5]
    assert get_positive([-1, -2, -3, -4, -5]) == []
    assert get_positive([0, 1, 2, 3, 4, 5]) == [0, 1, 2, 3, 4, 5]
    assert get_positive([10, 20, 30, 40, 50]) == [10, 20, 30, 40, 50]
    assert get_positive([-10, -20, -30, -40, -50]) == []
    assert get_positive([0]) == [0]
    assert get_positive([]) == []
    assert get_positive([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert get_positive([-1, -2, -3, -4, -5]) == []
    assert get_positive([0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0]
    assert get_positive([100, 200, 300, 400, 500]) == [100, 200, 300, 400, 500]
    assert get_positive([-100, -200, -300, -400, -500]) == []
    assert get_positive([5, 10, 15, 20, 25]) == [5, 10, 15, 20, 25]
    assert get_positive([-5, -10, -15, -20, -25]) == []
    assert get_positive([0, 5, 10, 15, 20, 25])",
is_prime,"def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.""""""","

METADATA = {}


def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

","def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.""""""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def is_palindrome(n):
    """"""Return true if a given number is a palindrome, and false otherwise.""""""
    return str(n) == str(n)[::-1]

def is_emirp(n):
    """"""Return true if a given number is an emirp, and false otherwise.""""""
    if is_prime(n) and is_prime(int(str(n)[::-1])) and n!= int(str(n)[::-1]):
        return True
    return False

def generate_emirps(limit):
    """"""Generate emirps up to a given limit.""""""
    emirps = []
    for i in range(1, limit):
        if is_emirp(i):
            emirps.append(i)
    return emirps

# Test the functions
print(is_prime(7))  # Output: True
print(is_palindrome(121))  # Output: True
print(is_emirp(13))  # Output: True
print(generate_emirps(20))  # Output: [13, 17]
",
find_zero,"import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.""""""","

METADATA = {}


def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

","import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.""""""
    assert len(xs) % 2 == 0, ""xs must have even number of coefficients""
    assert xs[-1]!= 0, ""largest coefficient must not be zero""
    return math.copysign(1, xs[-1]) * math.pow(abs(xs[-1]), 1 / len(xs))


def find_zeros(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zeros find all zeros of the polynomial.
    find_zeros returns a list of zero points.""""""
    assert len(xs) % 2 == 0, ""xs must have even number of coefficients""
    return [math.copysign(1, x) * math.pow(abs(x), 1 / len(xs)) for x in xs]


def test_poly():
    assert poly([1, 2, 3], 2) == 1 + 2 * 2 + 3 * 2**2


def test_find_zero():
    assert find_zero([1, 2, 3]) == -1


def test_find_zeros():
    assert find_zeros([1, 2, 3]) == [-1, -3]


test_poly()
test_find_zero()
test_find_zeros()",
sort_third,"def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.""""""","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

","def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.""""""
    l_prime = l.copy()
    l_prime[::3] = sorted(l[::3])
    return l_prime

# Test the function
test_list = [5, 2, 8, 1, 9, 3, 7, 4, 6]
print(sort_third(test_list))  # Output: [5, 2, 8, 1, 9, 3, 4, 7, 6]

# The function sorts the values at the indicies divisible by three in the input list",
unique,"def unique(l: list):
    """"""Return sorted unique elements in a list""""""","

METADATA = {}


def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

","def unique(l: list):
    """"""Return sorted unique elements in a list""""""
    return sorted(set(l))


def test_unique():
    assert unique([1, 2, 3, 1, 2, 3]) == [1, 2, 3]
    assert unique([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]
    assert unique([1, 1, 1, 1, 1]) == [1]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    assert unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5",
max_element,"def max_element(l: list):
    """"""Return maximum element in the list.""""""","

METADATA = {}


def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
","def max_element(l: list):
    """"""Return maximum element in the list.""""""
    return max(l)


def min_element(l: list):
    """"""Return minimum element in the list.""""""
    return min(l)


def sum_elements(l: list):
    """"""Return sum of elements in the list.""""""
    return sum(l)


def product_elements(l: list):
    """"""Return product of elements in the list.""""""
    product = 1
    for element in l:
        product *= element
    return product


def reverse_list(l: list):
    """"""Return reversed list.""""""
    return l[::-1]


def sort_list(l: list):
    """"""Return sorted list.""""""
    return sorted(l)


def remove_duplicates(l: list):
    """"""Return list without duplicates.""""""
    return list(set(l))


def remove_element(l: list, element):
    """"""Return list without specified element.""""""
    return [x for x in l if x!= element]


def remove_all_elements(l: list, element):
    """"""Return list without all specified elements.""""""
    return [x for x in l if x!= element]


def remove_all_elements_by_value(l: list, element):
    """"""Return list without all specified elements by value.""""""
    return [x for x in l if x!= element]


def remove_all_elements_by_index(l: list, index):
    """"""Return list without all specified elements by index.""""""
    return [x for x in l if l.index(x)!= index]


def remove_all_elements_by_value_and_index(l: list, value, index):
    """"""Return list without all specified elements by value and index.""""""
    return [x for x in l if x!= value and l.index(x)!= index]


def remove_all_elements_by_value_and_index_reverse(l: list, value, index):
    """"""Return list without all specified elements by value and index (reverse).""""""
    return [x for x in l if x!= value and l.index(x)!= index",
fizz_buzz,"def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.""""""","

METADATA = {}


def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

","def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.""""""
    count = 0
    for i in range(1, n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count

# Test the function with n = 100
print(fizz_buzz(100))  # Output: 24",
sort_even,"def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.""""""","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

","def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.""""""
    l_even = sorted([l[i] for i in range(len(l)) if i % 2 == 0])
    l_odd = [l[i] for i in range(len(l)) if i % 2!= 0]
    l_sorted = [l_even.pop(0) if i % 2 == 0 else l_odd.pop(0) for i in range(len(l))]
    return l_sorted

# Test the function
test_list = [5, 2, 8, 3, 9, 1]
print(sort_even(test_list))  # Output: [2, 8, 3, 9, 1, 5]

# The function correctly sorts the even indicies of the list while maintaining the odd indicies as they were in the original list.",
decode_cyclic,"

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","

METADATA = {}


def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

","

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def encode_rail_fence(s: str, n: int):
    """"""
    returns encoded string by zigzagging through the rail fence.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def decode_rail_fence(s: str, n: int):
    """"""
    takes as input string encoded with encode_rail_fence function. Returns decoded string.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def encode_rot13(s: str):
    """"""
    returns encoded string by rotating characters by 13 positions.
    """"""
    return s.translate(str.maketrans(
        ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"",
        ""nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM""))


def decode",
