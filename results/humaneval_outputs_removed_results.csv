entry_point,prompt,test_cases,generated_code,all_tests_passed,category
has_close_elements,"from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False

","from typing import List


def has_close_elements(numbers: List[float], threshold: float) -> bool:
    """""" Check if in given list of numbers, are any two numbers closer to each other than
    given threshold.
    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)
    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)
    """"""
    numbers.sort()
    for i in range(len(numbers) - 1):
        if numbers[i + 1] - numbers[i] < threshold:
            return True
    return False


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,ListArray
separate_paren_groups,"from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [
        '(()())', '((()))', '()', '((())()())'
    ]
    assert candidate('() (()) ((())) (((())))') == [
        '()', '(())', '((()))', '(((())))'
    ]
    assert candidate('(()(())((())))') == [
        '(()(())((())))'
    ]
    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']
","from typing import List


def separate_paren_groups(paren_string: str) -> List[str]:
    """""" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to
    separate those group into separate strings and return the list of those.
    Separate groups are balanced (each open brace is properly closed) and not nested within each other
    Ignore any spaces in the input string.
    >>> separate_paren_groups('( ) (( )) (( )( ))')
    """"""
    groups = []
    start_index = None
    count = 0

    for i in range(len(paren_string)):
        if paren_string[i] == '(':
            if count == 0:
                start_index = i
            count += 1
        elif paren_string[i] == ')':
            count -= 1
            if count == 0:
                groups.append(paren_string[start_index + 1:i])

    return groups


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Failed,DS
truncate_number,"

def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3.5) == 0.5
    assert abs(candidate(1.33) - 0.33) < 1e-6
    assert abs(candidate(123.456) - 0.456) < 1e-6
","

def truncate_number(number: float) -> float:
    """""" Given a positive floating point number, it can be decomposed into
    and integer part (largest integer smaller than given number) and decimals
    (leftover part always smaller than 1).

    Return the decimal part of the number.
    >>> truncate_number(3.5)
    """"""
    return number % 1


def main():
    number = 3.5
    truncated_number = truncate_number(number)
    print(f""The truncated number is: {truncated_number}"")


if __name__ == ""__main__"":
    main()",Passed,Math
below_zero,"from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    >>> below_zero([1, 2, 3])
    >>> below_zero([1, 2, -4, 5])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == False
    assert candidate([1, 2, -3, 1, 2, -3]) == False
    assert candidate([1, 2, -4, 5, 6]) == True
    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False
    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True
    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True
","from typing import List


def below_zero(operations: List[int]) -> bool:
    """""" You're given a list of deposit and withdrawal operations on a bank account that starts with
    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and
    at that point function should return True. Otherwise it should return False.
    >>> below_zero([1, 2, 3])
    >>> below_zero([1, 2, -4, 5])
    """"""
    balance = 0
    for operation in operations:
        balance += operation
        if balance < 0:
            return True
    return False


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,ListArray
mean_absolute_deviation,"from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6
    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6

","from typing import List


def mean_absolute_deviation(numbers: List[float]) -> float:
    """""" For a given list of input numbers, calculate Mean Absolute Deviation
    around the mean of this dataset.
    Mean Absolute Deviation is the average absolute difference between each
    element and a centerpoint (mean in this case):
    MAD = average | x - x_mean |
    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])
    """"""
    mean = sum(numbers) / len(numbers)
    deviations = [abs(num - mean) for num in numbers]
    mad = sum(deviations) / len(deviations)
    return mad


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
intersperse,"from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
    >>> intersperse([], 4)
    >>> intersperse([1, 2, 3], 4)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 7) == []
    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]
    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]
","from typing import List


def intersperse(numbers: List[int], delimeter: int) -> List[int]:
    """""" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'
    >>> intersperse([], 4)
    >>> intersperse([1, 2, 3], 4)
    """"""
    return [numbers[i] if i % 2 == 0 else delimeter for i in range(len(numbers) * 2 - 1)]


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Error,ListArray
parse_nested_parens,"from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]
","from typing import List


def parse_nested_parens(paren_string: str) -> List[int]:
    """""" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.
    For each of the group, output the deepest level of nesting of parentheses.
    E.g. (()()) has maximum two levels of nesting while ((())) has three.

    >>> parse_nested_parens('(()()) ((())) () ((())()())')
    """"""
    result = []
    for group in paren_string.split():
        stack = []
        max_depth = 0
        for char in group:
            if char == '(':
                stack.append('(')
                max_depth = max(max_depth, len(stack))
            elif char == ')':
                if stack:
                    stack.pop()
        result.append(max_depth)
    return result


if __name__ == '__main__':
    import doctest
    doctest.testmod()",Passed,DS
filter_by_substring,"from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']
","from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """"""
    return [s for s in strings if substring in s]


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,String
sum_product,"from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    >>> sum_product([1, 2, 3, 4])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
","from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """""" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    >>> sum_product([1, 2, 3, 4])
    """"""
    if not numbers:
        return 0, 1
    else:
        sum_result = sum(numbers)
        product_result = 1
        for num in numbers:
            product_result *= num
        return sum_result, product_result


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Passed,Math
rolling_max,"from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]
    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]
","from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """""" From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    """"""
    rolling_max_list = []
    max_element = float('-inf')

    for num in numbers:
        max_element = max(max_element, num)
        rolling_max_list.append(max_element)

    return rolling_max_list


def max_subarray_sum(numbers: List[int], k: int) -> int:
    """""" Find the maximum sum of a subarray of size k in a given list of integers.
    >>> max_subarray_sum([1, 2, 3, 2, 3, 4, 2], 3)
    """"""
    max_sum = float('-inf')
    current_sum = 0

    for i in range(len(numbers) - k + 1):
        current_sum = sum(numbers[i:i + k])
        max_sum = max(max_sum, current_sum)

    return max_sum


def max_subarray_sum_rolling(numbers: List[int], k: int) -> int:
    """""" Find the maximum sum of a subarray of size k in a given list of integers using rolling window technique.
    >>> max_subarray_sum_rolling([1, 2, 3, 2, 3, 4, 2], 3)
    """"""
    max_sum = float('-inf')
    current_sum = sum(numbers[:k])

    for i in range(1, len(numbers) - k + 1):
        current_sum = current_sum - numbers[i - 1] + numbers[i + k - 1]
        max_sum = max(max_sum, current_sum)

    return max_sum


def min_subarray_sum(numbers: List[int], k: int) -> int:
    """""" Find the minimum sum of a subarray of size k in a given list of integers.
    >>> min_subarray_sum([1, 2, 3, 2, 3, 4, 2], 3)
    """"""
    min_sum = float('inf')
    current_sum = 0

    for",Error,ListArray
make_palindrome,"

def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    >>> make_palindrome('cat')
    >>> make_palindrome('cata')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('x') == 'x'
    assert candidate('xyz') == 'xyzyx'
    assert candidate('xyx') == 'xyx'
    assert candidate('jerry') == 'jerryrrej'
","

def is_palindrome(string: str) -> bool:
    """""" Test if given string is a palindrome """"""
    return string == string[::-1]


def make_palindrome(string: str) -> str:
    """""" Find the shortest palindrome that begins with a supplied string.
    Algorithm idea is simple:
    - Find the longest postfix of supplied string that is a palindrome.
    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.
    >>> make_palindrome('')
    >>> make_palindrome('cat')
    >>> make_palindrome('cata')
    """"""
    if not string:
        return ''
    if is_palindrome(string):
        return string
    for i in range(len(string) - 1, 0, -1):
        if is_palindrome(string[:i]):
            return string[i:][::-1] + string
    return string[1:][::-1] + string[0]


if __name__ == '__main__':
    import doctest
    doctest.testmod()",Failed,String
string_xor,"from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    >>> string_xor('010', '110')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('111000', '101010') == '010010'
    assert candidate('1', '1') == '0'
    assert candidate('0101', '0000') == '0101'
","from typing import List


def string_xor(a: str, b: str) -> str:
    """""" Input are two strings a and b consisting only of 1s and 0s.
    Perform binary XOR on these inputs and return result also as a string.
    >>> string_xor('010', '110')
    """"""
    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))


def string_xor_list(lst: List[str]) -> str:
    """""" Input is a list of strings consisting only of 1s and 0s.
    Perform binary XOR on all strings in the list and return result also as a string.
    >>> string_xor_list(['010', '110', '101'])
    """"""
    result = lst[0]
    for i in range(1, len(lst)):
        result = string_xor(result, lst[i])
    return result


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Passed,String
longest,"from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    >>> longest([])
    >>> longest(['a', 'b', 'c'])
    >>> longest(['a', 'bb', 'ccc'])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == None
    assert candidate(['x', 'y', 'z']) == 'x'
    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'
","from typing import List, Optional


def longest(strings: List[str]) -> Optional[str]:
    """""" Out of list of strings, return the longest one. Return the first one in case of multiple
    strings of the same length. Return None in case the input list is empty.
    >>> longest([])
    >>> longest(['a', 'b', 'c'])
    >>> longest(['a', 'bb', 'ccc'])
    """"""
    if not strings:
        return None
    return max(strings, key=len)


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,String
greatest_common_divisor,"

def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b
    >>> greatest_common_divisor(3, 5)
    >>> greatest_common_divisor(25, 15)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3, 7) == 1
    assert candidate(10, 15) == 5
    assert candidate(49, 14) == 7
    assert candidate(144, 60) == 12
","

def greatest_common_divisor(a: int, b: int) -> int:
    """""" Return a greatest common divisor of two integers a and b
    >>> greatest_common_divisor(3, 5)
    >>> greatest_common_divisor(25, 15)
    """"""
    while a!= b:
        if a > b:
            a -= b
        else:
            b -= a
    return a


def least_common_multiple(a: int, b: int) -> int:
    """""" Return a least common multiple of two integers a and b
    >>> least_common_multiple(3, 5)
    >>> least_common_multiple(25, 15)
    """"""
    return a * b // greatest_common_divisor(a, b)


def main():
    print(greatest_common_divisor(3, 5))
    print(greatest_common_divisor(25, 15))
    print(least_common_multiple(3, 5))
    print(least_common_multiple(25, 15))


if __name__ == ""__main__"":
    main()",Passed,Math
all_prefixes,"from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']
    assert candidate('WWW') == ['W', 'WW', 'WWW']
","from typing import List


def all_prefixes(string: str) -> List[str]:
    """""" Return list of all prefixes from shortest to longest of the input string
    >>> all_prefixes('abc')
    """"""
    return [string[:i] for i in range(1, len(string) + 1)]


def all_suffixes(string: str) -> List[str]:
    """""" Return list of all suffixes from shortest to longest of the input string
    >>> all_suffixes('abc')
    """"""
    return [string[i:] for i in range(len(string))]


def all_substrings(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string
    >>> all_substrings('abc')
    """"""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_2(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string
    >>> all_substrings_2('abc')
    """"""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_3(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string
    >>> all_substrings_3('abc')
    """"""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_4(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string
    >>> all_substrings_4('abc')
    """"""
    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]


def all_substrings_5(string: str) -> List[str]:
    """""" Return list of all substrings from shortest to longest of the input string
    >>> all_substrings_5('abc')
    """"""
    return [string[i:j] for i in range(",Error,String
string_sequence,"

def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    >>> string_sequence(0)
    >>> string_sequence(5)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(0) == '0'
    assert candidate(3) == '0 1 2 3'
    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'
","

def string_sequence(n: int) -> str:
    """""" Return a string containing space-delimited numbers starting from 0 upto n inclusive.
    >>> string_sequence(0)
    >>> string_sequence(5)
    """"""
    return "" "".join(str(i) for i in range(n+1))


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,String
count_distinct_characters,"

def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of
    >>> count_distinct_characters('xyzXYZ')
    >>> count_distinct_characters('Jerry')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('abcde') == 5
    assert candidate('abcde' + 'cade' + 'CADE') == 5
    assert candidate('aaaaAAAAaaaa') == 1
    assert candidate('Jerry jERRY JeRRRY') == 5
","

def count_distinct_characters(string: str) -> int:
    """""" Given a string, find out how many distinct characters (regardless of case) does it consist of
    >>> count_distinct_characters('xyzXYZ')
    >>> count_distinct_characters('Jerry')
    """"""
    return len(set(string.lower()))


if __name__ == '__main__':
    import doctest
    doctest.testmod()",Passed,String
parse_music,"from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == []
    assert candidate('o o o o') == [4, 4, 4, 4]
    assert candidate('.| .| .| .|') == [1, 1, 1, 1]
    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]
    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]
","from typing import List


def parse_music(music_string: str) -> List[int]:
    """""" Input to this function is a string representing musical notes in a special ASCII format.
    Your task is to parse this string and return list of integers corresponding to how many beats does each
    not last.

    Here is a legend:
    'o' - whole note, lasts four beats
    'o|' - half note, lasts two beats
    '.|' - quater note, lasts one beat

    >>> parse_music('o o| .| o| o| .| .| .| .| o o')
    """"""
    music_dict = {'o': 4, 'o|': 2, '.|': 1}
    music_list = music_string.split()
    parsed_music = [music_dict[note] for note in music_list]
    return parsed_music


if __name__ == '__main__':
    import doctest

    doctest.testmod()",Passed,DS
how_many_times,"

def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.
    >>> how_many_times('', 'a')
    >>> how_many_times('aaa', 'a')
    >>> how_many_times('aaaa', 'aa')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('', 'x') == 0
    assert candidate('xyxyxyx', 'x') == 4
    assert candidate('cacacacac', 'cac') == 4
    assert candidate('john doe', 'john') == 1
","

def how_many_times(string: str, substring: str) -> int:
    """""" Find how many times a given substring can be found in the original string. Count overlaping cases.
    >>> how_many_times('', 'a')
    >>> how_many_times('aaa', 'a')
    >>> how_many_times('aaaa', 'aa')
    """"""
    if not string or not substring:
        return 0

    count = 0
    start_index = 0

    while start_index <= len(string) - len(substring):
        found_index = string.find(substring, start_index)
        if found_index == -1:
            break
        count += 1
        start_index = found_index + 1

    return count


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,String
sort_numbers,"from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'
","from typing import List


def sort_numbers(numbers: str) -> str:
    """""" Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    """"""
    number_dict = {
        'zero': 0,
        'one': 1,
        'two': 2,
        'three': 3,
        'four': 4,
        'five': 5,
       'six': 6,
       'seven': 7,
        'eight': 8,
        'nine': 9
    }

    numbers_list = numbers.split()
    sorted_numbers = sorted(numbers_list, key=lambda x: number_dict[x])

    return''.join(sorted_numbers)


if __name__ == '__main__':
    import doctest
    doctest.testmod()",Failed,ListArray
find_closest_elements,"from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)
    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)
    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)

","from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """""" From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    """"""
    numbers.sort()
    min_difference = float('inf')
    closest_pair = ()

    for i in range(len(numbers) - 1):
        difference = numbers[i + 1] - numbers[i]
        if difference < min_difference:
            min_difference = difference
            closest_pair = (numbers[i], numbers[i + 1])

    return closest_pair


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Passed,ListArray
rescale_to_unit,"from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([2.0, 49.9]) == [0.0, 1.0]
    assert candidate([100.0, 49.9]) == [1.0, 0.0]
    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]
    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]
","from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    """"""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) for num in numbers]


def rescale_to_unit_interval(numbers: List[float]) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit_interval([1.0, 2.0, 3.0, 4.0, 5.0])
    """"""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val) / (max_val - min_val) for num in numbers]


def rescale_to_unit_interval_with_offset(numbers: List[float], offset: float) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit_interval_with_offset([1.0, 2.0, 3.0, 4.0, 5.0], 1.0)
    """"""
    min_val = min(numbers)
    max_val = max(numbers)
    if min_val == max_val:
        return [0.0] * len(numbers)
    return [(num - min_val - offset) / (max_val - min_val) for num in numbers]


def rescale_to_unit_interval_with_offset_and_scale(numbers: List[float], offset: float, scale: float) -> List[float]:
    """""" Given list of numbers (of at least two elements), apply a linear transform to that list,
",Error,Math
filter_integers,"from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers
    >>> filter_integers(['a', 3.14, 5])
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]
    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]
","from typing import List, Any


def filter_integers(values: List[Any]) -> List[int]:
    """""" Filter given list of any python values only for integers
    >>> filter_integers(['a', 3.14, 5])
    >>> filter_integers([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, int)]


def filter_strings(values: List[Any]) -> List[str]:
    """""" Filter given list of any python values only for strings
    >>> filter_strings(['a', 3.14, 5])
    >>> filter_strings([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, str)]


def filter_dicts(values: List[Any]) -> List[dict]:
    """""" Filter given list of any python values only for dictionaries
    >>> filter_dicts(['a', 3.14, 5])
    >>> filter_dicts([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, dict)]


def filter_lists(values: List[Any]) -> List[list]:
    """""" Filter given list of any python values only for lists
    >>> filter_lists(['a', 3.14, 5])
    >>> filter_lists([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, list)]


def filter_tuples(values: List[Any]) -> List[tuple]:
    """""" Filter given list of any python values only for tuples
    >>> filter_tuples(['a', 3.14, 5])
    >>> filter_tuples([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, tuple)]


def filter_sets(values: List[Any]) -> List[set]:
    """""" Filter given list of any python values only for sets
    >>> filter_sets(['a', 3.14, 5])
    >>> filter_sets([1, 2, 3, 'abc', {}, []])
    """"""
    return [value for value in values if isinstance(value, set)]


def filter_floats(values: List[Any]) -> List[float]:
   ",Error,ListArray
strlen,"

def strlen(string: str) -> int:
    """""" Return length of given string
    >>> strlen('')
    >>> strlen('abc')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == 0
    assert candidate('x') == 1
    assert candidate('asdasnakj') == 9
","

def strlen(string: str) -> int:
    """""" Return length of given string
    >>> strlen('')
    >>> strlen('abc')
    """"""
    return len(string)


def strcmp(str1: str, str2: str) -> bool:
    """""" Compare two strings
    >>> strcmp('abc', 'abc')
    """"""
    return str1 == str2


def strncmp(str1: str, str2: str, n: int) -> bool:
    """""" Compare two strings up to n characters
    >>> strncmp('abc', 'abd', 2)
    """"""
    return str1[:n] == str2[:n]


def strchr(string: str, char: str) -> int:
    """""" Return index of first occurrence of char in string
    >>> strchr('abc', 'b')
    """"""
    return string.find(char)


def strrchr(string: str, char: str) -> int:
    """""" Return index of last occurrence of char in string
    >>> strrchr('abcabc', 'b')
    """"""
    return string.rfind(char)


def strstr(haystack: str, needle: str) -> int:
    """""" Return index of first occurrence of needle in haystack
    >>> strstr('abcabc', 'bc')
    """"""
    return haystack.find(needle)


def strpbrk(string: str, chars: str) -> int:
    """""" Return index of first occurrence of any char in chars in string
    >>> strpbrk('abc', 'bd')
    """"""
    for i, char in enumerate(string):
        if char in chars:
            return i
    return -1


def strspn(string: str, chars: str) -> int:
    """""" Return length of initial segment of string consisting only of chars
    >>> strspn('abc', 'bd')
    """"""
    for i, char in enumerate(string):
        if char not in chars:
            return i
    return len(string)


def strcspn(string: str, chars: str) -> int:
    """""" Return length of initial segment of string not consisting of chars
    >>> strcspn",Error,String
largest_divisor,"

def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(3) == 1
    assert candidate(7) == 1
    assert candidate(10) == 5
    assert candidate(100) == 50
    assert candidate(49) == 7
","

def largest_divisor(n: int) -> int:
    """""" For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    """"""
    for i in range(n-1, 0, -1):
        if n % i == 0:
            return i


def smallest_multiple(n: int) -> int:
    """""" For a given number n, find the smallest number that is a multiple of n, greater than n
    >>> smallest_multiple(15)
    """"""
    for i in range(n+1, n*n):
        if i % n == 0:
            return i


def is_prime(n: int) -> bool:
    """""" Check if a number n is prime
    >>> is_prime(15)
    """"""
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True


def prime_factors(n: int) -> list:
    """""" Find all prime factors of a number n
    >>> prime_factors(15)
    """"""
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors


def is_palindrome(n: int) -> bool:
    """""" Check if a number n is a palindrome
    >>> is_palindrome(15)
    """"""
    return str(n) == str(n)[::-1]


def is_pandigital(n: int, length: int) -> bool:
    """""" Check if a number n is pandigital (contains all digits from 1 to length)
    >>> is_pandigital(15, 3)
    """"""
    return sorted(str(n)) == [str(i) for i in range(1, length+1)]


def is_permutation(n: int, m: int) -> bool:
    """""" Check if two numbers n and m are permutations of each other
    >>> is_permutation(15, ",Error,Math
factorize,"from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    >>> factorize(25)
    >>> factorize(70)
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate(2) == [2]
    assert candidate(4) == [2, 2]
    assert candidate(8) == [2, 2, 2]
    assert candidate(3 * 19) == [3, 19]
    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]
    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]
    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]
    assert candidate(3 * 2 * 3) == [2, 3, 3]
","from typing import List


def factorize(n: int) -> List[int]:
    """""" Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    >>> factorize(25)
    >>> factorize(70)
    """"""
    factors = []
    divisor = 2
    while n > 1:
        if n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        else:
            divisor += 1
    return factors


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
remove_duplicates,"from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == []
    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]
    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]
","from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """""" From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    """"""
    unique_numbers = []
    seen = set()

    for num in numbers:
        if num not in seen:
            unique_numbers.append(num)
            seen.add(num)

    return unique_numbers


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Failed,ListArray
flip_case,"

def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    >>> flip_case('Hello')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('Hello!') == 'hELLO!'
    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'
","

def flip_case(string: str) -> str:
    """""" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    >>> flip_case('Hello')
    """"""
    return ''.join(c.lower() if c.isupper() else c.upper() for c in string)


def main():
    print(flip_case('Hello'))


if __name__ == '__main__':
    main()",Passed,String
concatenate,"from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string
    >>> concatenate([])
    >>> concatenate(['a', 'b', 'c'])
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == ''
    assert candidate(['x', 'y', 'z']) == 'xyz'
    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'
","from typing import List


def concatenate(strings: List[str]) -> str:
    """""" Concatenate list of strings into a single string
    >>> concatenate([])
    >>> concatenate(['a', 'b', 'c'])
    """"""
    return """".join(strings)


def reverse(string: str) -> str:
    """""" Reverse a string
    >>> reverse('')
    >>> reverse('abc')
    """"""
    return string[::-1]


def is_palindrome(string: str) -> bool:
    """""" Check if a string is a palindrome
    >>> is_palindrome('')
    True
    >>> is_palindrome('a')
    True
    >>> is_palindrome('aa')
    True
    >>> is_palindrome('ab')
    False
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('abba')
    True
    >>> is_palindrome('abcba')
    True
    >>> is_palindrome('abccba')
    True
    >>> is_palindrome('abcdcba')
    True
    >>> is_palindrome('abcdefg')
    False
    """"""
    return string == string[::-1]


def is_palindrome_recursive(string: str) -> bool:
    """""" Check if a string is a palindrome recursively
    >>> is_palindrome_recursive('')
    True
    >>> is_palindrome_recursive('a')
    True
    >>> is_palindrome_recursive('aa')
    True
    >>> is_palindrome_recursive('ab')
    False
    >>> is_palindrome_recursive('aba')
    True
    >>> is_palindrome_recursive('abba')
    True
    >>> is_palindrome_recursive('abcba')
    True
    >>> is_palindrome_recursive('abccba')
    True
    >>> is_palindrome_recursive('abcdcba')
    True
    >>> is_palindrome_recursive('abcdefg')
    False
    """"""
    if len(string) < 2:
        return True
    if string[0]!= string[-1]:
        return False
    return is_palind",Passed,String
filter_by_prefix,"from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    """"""
","

METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
","from typing import List


def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that start with a given prefix.
    >>> filter_by_prefix([], 'a')
    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')
    """"""
    return [s for s in strings if s.startswith(prefix)]


def filter_by_suffix(strings: List[str], suffix: str) -> List[str]:
    """""" Filter an input list of strings only for ones that end with a given suffix.
    >>> filter_by_suffix([], 'a')
    >>> filter_by_suffix(['abc', 'bcd', 'cde', 'array'], 'a')
    """"""
    return [s for s in strings if s.endswith(suffix)]


def filter_by_length(strings: List[str], length: int) -> List[str]:
    """""" Filter an input list of strings only for ones that have a given length.
    >>> filter_by_length([], 1)
    >>> filter_by_length(['abc', 'bcd', 'cde', 'array'], 3)
    """"""
    return [s for s in strings if len(s) == length]


def filter_by_pattern(strings: List[str], pattern: str) -> List[str]:
    """""" Filter an input list of strings only for ones that match a given pattern.
    >>> filter_by_pattern([], 'a')
    >>> filter_by_pattern(['abc', 'bcd', 'cde', 'array'], 'a*')
    """"""
    return [s for s in strings if len(s) == len(pattern) and all(s[i] == pattern[i] or pattern[i] == '*' for i in range(len(s)))]


def filter_by_contains(strings: List[str], substring: str) -> List[str]:
    """""" Filter an input list of strings only for ones that contain a given substring.
    >>> filter_by_contains([], 'a')
    >>> filter_by_contains(['abc', 'bcd', 'cde', 'array'], 'a')
    """"""
    return [s for s in strings if substring in s]


def filter_by_unique_chars(strings: List[str]) -> List[str]:
    """""" Filter an input list of strings only for ones that contain unique characters.
    >>> filter_",Error,String
get_positive,"

def get_positive(l: list):
    """"""Return only positive numbers in the list.
    >>> get_positive([-1, 2, -4, 5, 6])
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]
    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]
    assert candidate([-1, -2]) == []
    assert candidate([]) == []

","

def get_positive(l: list):
    """"""Return only positive numbers in the list.
    >>> get_positive([-1, 2, -4, 5, 6])
    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return [num for num in l if num > 0]


def get_even(l: list):
    """"""Return only even numbers in the list.
    >>> get_even([1, 2, 3, 4, 5])
    >>> get_even([5, 3, 5, 2, 3, 3, 9, 0, 123, 1, 10])
    """"""
    return [num for num in l if num % 2 == 0]


def get_odd(l: list):
    """"""Return only odd numbers in the list.
    >>> get_odd([1, 2, 3, 4, 5])
    >>> get_odd([5, 3, 5, 2, 3, 3, 9, 0, 123, 1, 10])
    """"""
    return [num for num in l if num % 2!= 0]


def get_palindromes(l: list):
    """"""Return only palindromes in the list.
    >>> get_palindromes([121, 232, 343, 454, 565])
    >>> get_palindromes([5, 3, 5, 2, 3, 3, 9, 0, 123, 1, 10])
    """"""
    return [num for num in l if str(num) == str(num)[::-1]]


def get_primes(l: list):
    """"""Return only prime numbers in the list.
    >>> get_primes([1, 2, 3, 4, 5])
    >>> get_primes([5, 3, 5, 2, 3, 3, 9, 0, 123, 1, 10])
    """"""
    return [num for num in l if is_prime(num)]


def is_prime(num: int):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
",Error,ListArray
is_prime,"

def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.
    >>> is_prime(6)
    >>> is_prime(101)
    >>> is_prime(11)
    >>> is_prime(13441)
    >>> is_prime(61)
    >>> is_prime(4)
    >>> is_prime(1)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(6) == False
    assert candidate(101) == True
    assert candidate(11) == True
    assert candidate(13441) == True
    assert candidate(61) == True
    assert candidate(4) == False
    assert candidate(1) == False
    assert candidate(5) == True
    assert candidate(11) == True
    assert candidate(17) == True
    assert candidate(5 * 17) == False
    assert candidate(11 * 7) == False
    assert candidate(13441 * 19) == False

","

def is_prime(n):
    """"""Return true if a given number is prime, and false otherwise.
    >>> is_prime(6)
    >>> is_prime(101)
    >>> is_prime(11)
    >>> is_prime(13441)
    >>> is_prime(61)
    >>> is_prime(4)
    >>> is_prime(1)
    """"""
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True


def is_palindrome(s):
    """"""Return true if a given string is a palindrome, and false otherwise.
    >>> is_palindrome(""racecar"")
    >>> is_palindrome(""hello"")
    >>> is_palindrome(""madam"")
    >>> is_palindrome(""a"")
    >>> is_palindrome("""")
    """"""
    return s == s[::-1]


def is_anagram(s1, s2):
    """"""Return true if two strings are anagrams of each other, and false otherwise.
    >>> is_anagram(""listen"", ""silent"")
    >>> is_anagram(""hello"", ""world"")
    >>> is_anagram(""debit card"", ""bad credit"")
    >>> is_anagram(""python"", ""java"")
    >>> is_anagram(""silent"", ""listen"")
    """"""
    return sorted(s1.replace("" "", """")) == sorted(s2.replace("" "", """"))


def is_pangram(s):
    """"""Return true if a given string is a pangram, and false otherwise.
    >>> is_pangram(""The quick brown fox jumps over the lazy dog"")
    >>> is_pangram(""Pack my box with five dozen liquor jugs"")
    >>> is_pangram(""Hello, world!"")
    >>> is_pangram(""abcdefghijklmnopqrstuvwxyz"")
    >>> is_pangram("""")
    """"""
    return set(s.lower()) >= set(""abcdefghijklmnopqrstuvwxyz"")


def is_perfect_square(n):
    """"""Return true if a given number is a perfect square, and false otherwise.
    >>> is_perfect_square(16)
    >>> is_perfect_square(14",Error,Math
find_zero,"import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    """"""
","

METADATA = {}


def check(candidate):
    import math
    import random
    rng = random.Random(42)
    import copy
    for _ in range(100):
        ncoeff = 2 * rng.randint(1, 4)
        coeffs = []
        for _ in range(ncoeff):
            coeff = rng.randint(-10, 10)
            if coeff == 0:
                coeff = 1
            coeffs.append(coeff)
        solution = candidate(copy.deepcopy(coeffs))
        assert math.fabs(poly(coeffs, solution)) < 1e-4

","import math


def poly(xs: list, x: float):
    """"""
    Evaluates polynomial with coefficients xs at point x.
    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n
    """"""
    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])


def find_zero(xs: list):
    """""" xs are coefficients of a polynomial.
    find_zero find x such that poly(x) = 0.
    find_zero returns only only zero point, even if there are many.
    Moreover, find_zero only takes list xs having even number of coefficients
    and largest non zero coefficient as it guarantees
    a solution.
    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x
    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3
    """"""
    assert len(xs) % 2 == 0, ""xs must have even number of coefficients""
    assert xs[-1]!= 0, ""largest coefficient must not be zero""
    return math.pow(-xs[-2] / (2 * xs[-3]), 1 / len(xs))


if __name__ == ""__main__"":
    import doctest

    doctest.testmod()",Error,Math
sort_third,"

def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.
    >>> sort_third([1, 2, 3])
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    """"""
","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])
    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])
    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])
    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])

","

def sort_third(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal
    to the values of the corresponding indicies of l, but sorted.
    >>> sort_third([1, 2, 3])
    >>> sort_third([5, 6, 3, 4, 8, 9, 2])
    """"""
    l_copy = l.copy()
    l_copy.sort()
    for i in range(len(l)):
        if i % 3 == 0:
            l[i] = l_copy[i]
    return l


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Failed,ListArray
unique,"

def unique(l: list):
    """"""Return sorted unique elements in a list
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]

","

def unique(l: list):
    """"""Return sorted unique elements in a list
    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return sorted(set(l))


def unique_in_order(l: list):
    """"""Return unique elements in order
    >>> unique_in_order([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x for i, x in enumerate(l) if i == 0 or x!= l[i - 1]]


def unique_in_order_with_count(l: list):
    """"""Return unique elements in order with count
    >>> unique_in_order_with_count([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [(x, l.count(x)) for x in set(l) if l.count(x) > 1]


def unique_in_order_with_count_and_index(l: list):
    """"""Return unique elements in order with count and index
    >>> unique_in_order_with_count_and_index([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [(x, l.count(x), l.index(x)) for x in set(l) if l.count(x) > 1]


def unique_in_order_with_count_and_index_and_last_index(l: list):
    """"""Return unique elements in order with count and index and last index
    >>> unique_in_order_with_count_and_index_and_last_index([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [(x, l.count(x), l.index(x), l.index(x) + l.count(x) - 1) for x in set(l) if l.count(x) > 1]


def unique_in_order_with_count_and_index_and_last_index_and_range(l: list):
    """"""Return unique elements in order with count",Error,ListArray
max_element,"

def max_element(l: list):
    """"""Return maximum element in the list.
    >>> max_element([1, 2, 3])
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([1, 2, 3]) == 3
    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124
","

def max_element(l: list):
    """"""Return maximum element in the list.
    >>> max_element([1, 2, 3])
    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return max(l)


def min_element(l: list):
    """"""Return minimum element in the list.
    >>> min_element([1, 2, 3])
    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return min(l)


def sum_elements(l: list):
    """"""Return sum of elements in the list.
    >>> sum_elements([1, 2, 3])
    >>> sum_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return sum(l)


def product_elements(l: list):
    """"""Return product of elements in the list.
    >>> product_elements([1, 2, 3])
    >>> product_elements([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    product = 1
    for element in l:
        product *= element
    return product


def reverse_list(l: list):
    """"""Return reversed list.
    >>> reverse_list([1, 2, 3])
    >>> reverse_list([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return l[::-1]


def sort_list(l: list):
    """"""Return sorted list.
    >>> sort_list([1, 2, 3])
    >>> sort_list([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])
    """"""
    return sorted(l)


def remove_duplicates(l: list):
    """"""Return list without duplicates.
    >>> remove_duplicates([1, 2, 3])
    >>> remove_duplic",Error,ListArray
fizz_buzz,"

def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    >>> fizz_buzz(50)
    >>> fizz_buzz(78)
    >>> fizz_buzz(79)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(50) == 0
    assert candidate(78) == 2
    assert candidate(79) == 3
    assert candidate(100) == 3
    assert candidate(200) == 6
    assert candidate(4000) == 192
    assert candidate(10000) == 639
    assert candidate(100000) == 8026

","

def fizz_buzz(n: int):
    """"""Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.
    >>> fizz_buzz(50)
    >>> fizz_buzz(78)
    >>> fizz_buzz(79)
    """"""
    count = 0
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            count += str(i).count('7')
    return count


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
sort_even,"

def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even([1, 2, 3])
    >>> sort_even([5, 6, 3, 4])
    """"""
","

METADATA = {}


def check(candidate):
    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])
    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])
    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])

","

def sort_even(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even([1, 2, 3])
    >>> sort_even([5, 6, 3, 4])
    """"""
    return [l[i] if i % 2!= 0 else sorted(l)[i//2] for i in range(len(l))]


def sort_even_2(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even_2([1, 2, 3])
    >>> sort_even_2([5, 6, 3, 4])
    """"""
    sorted_even = sorted(l[i] for i in range(len(l)) if i % 2 == 0)
    return [sorted_even.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]


def sort_even_3(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even_3([1, 2, 3])
    >>> sort_even_3([5, 6, 3, 4])
    """"""
    sorted_even = sorted(l[i] for i in range(len(l)) if i % 2 == 0)
    return [sorted_even.pop(0) if i % 2 == 0 else l[i] for i in range(len(l))]


def sort_even_4(l: list):
    """"""This function takes a list l and returns a list l' such that
    l' is identical to l in the odd indicies, while its values at the even indicies are equal
    to the values of the even indicies of l, but sorted.
    >>> sort_even_4([1, 2, 3])
    >>> sort_even_4([5, 6, 3, 4])
    """"""
    sorted_even = sorted(l[i] for i in range(",Error,ListArray
decode_cyclic,"

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
","

METADATA = {}


def check(candidate):
    from random import randint, choice
    import string

    letters = string.ascii_lowercase
    for _ in range(100):
        str = ''.join(choice(letters) for i in range(randint(10, 20)))
        encoded_str = encode_cyclic(str)
        assert candidate(encoded_str) == str

","

def encode_cyclic(s: str):
    """"""
    returns encoded string by cycling groups of three characters.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def decode_cyclic(s: str):
    """"""
    takes as input string encoded with encode_cyclic function. Returns decoded string.
    """"""
    # split string to groups. Each of length 3.
    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]
    # cycle elements in each group. Unless group has fewer elements than 3.
    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]
    return """".join(groups)


def encode_rail_fence(s: str, n: int):
    """"""
    returns encoded string by zigzagging through the rail fence.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def decode_rail_fence(s: str, n: int):
    """"""
    takes as input string encoded with encode_rail_fence function. Returns decoded string.
    """"""
    # split string to rows. Each of length n.
    rows = [s[(n * i):min((n * i + n), len(s))] for i in range((len(s) + n - 1) // n)]
    # zigzag through rows.
    return """".join(["""".join([row[i] for row in rows]) for i in range(n)])


def encode_rot13(s: str):
    """"""
    returns encoded string by rotating characters by 13 positions.
    """"""
    return s.translate(str.maketrans(
        ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"",
        ""nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM""))


def decode",Error,String
prime_fib,"

def prime_fib(n: int):
    """"""
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    >>> prime_fib(1)
    >>> prime_fib(2)
    >>> prime_fib(3)
    >>> prime_fib(4)
    >>> prime_fib(5)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(1) == 2
    assert candidate(2) == 3
    assert candidate(3) == 5
    assert candidate(4) == 13
    assert candidate(5) == 89
    assert candidate(6) == 233
    assert candidate(7) == 1597
    assert candidate(8) == 28657
    assert candidate(9) == 514229
    assert candidate(10) == 433494437

","

def prime_fib(n: int):
    """"""
    prime_fib returns n-th number that is a Fibonacci number and it's also prime.
    >>> prime_fib(1)
    >>> prime_fib(2)
    >>> prime_fib(3)
    >>> prime_fib(4)
    >>> prime_fib(5)
    """"""
    pass


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Failed,Math
triples_sum_to_zero,"

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    >>> triples_sum_to_zero([1, 3, -2, 1])
    >>> triples_sum_to_zero([1, 2, 3, 7])
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    >>> triples_sum_to_zero([1])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, 5, -1]) == False
    assert candidate([1, 3, -2, 1]) == True
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([1, 2, 5, 7]) == False
    assert candidate([2, 4, -5, 3, 9, 7]) == True
    assert candidate([1]) == False
    assert candidate([1, 3, 5, -100]) == False
    assert candidate([100, 3, 5, -100]) == False

","

def triples_sum_to_zero(l: list):
    """"""
    triples_sum_to_zero takes a list of integers as an input.
    it returns True if there are three distinct elements in the list that
    sum to zero, and False otherwise.

    >>> triples_sum_to_zero([1, 3, 5, 0])
    >>> triples_sum_to_zero([1, 3, -2, 1])
    >>> triples_sum_to_zero([1, 2, 3, 7])
    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])
    >>> triples_sum_to_zero([1])
    """"""
    l.sort()
    for i in range(len(l) - 2):
        j = i + 1
        k = len(l) - 1
        while j < k:
            if l[i] + l[j] + l[k] == 0:
                return True
            elif l[i] + l[j] + l[k] < 0:
                j += 1
            else:
                k -= 1
    return False


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,ListArray
car_race_collision,"

def car_race_collision(n: int):
    """"""
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(2) == 4
    assert candidate(3) == 9
    assert candidate(4) == 16
    assert candidate(8) == 64
    assert candidate(10) == 100

","

def car_race_collision(n: int):
    """"""
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """"""
    return n * (n - 1) // 2


if __name__ == ""__main__"":
    print(car_race_collision(1000))",Failed,DS
incr_list,"

def incr_list(l: list):
    """"""Return list with elements incremented by 1.
    >>> incr_list([1, 2, 3])
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([]) == []
    assert candidate([3, 2, 1]) == [4, 3, 2]
    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]

","

def incr_list(l: list):
    """"""Return list with elements incremented by 1.
    >>> incr_list([1, 2, 3])
    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x + 1 for x in l]


def decr_list(l: list):
    """"""Return list with elements decremented by 1.
    >>> decr_list([1, 2, 3])
    >>> decr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x - 1 for x in l]


def square_list(l: list):
    """"""Return list with elements squared.
    >>> square_list([1, 2, 3])
    >>> square_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x ** 2 for x in l]


def cube_list(l: list):
    """"""Return list with elements cubed.
    >>> cube_list([1, 2, 3])
    >>> cube_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x ** 3 for x in l]


def double_list(l: list):
    """"""Return list with elements doubled.
    >>> double_list([1, 2, 3])
    >>> double_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x * 2 for x in l]


def halve_list(l: list):
    """"""Return list with elements halved.
    >>> halve_list([1, 2, 3])
    >>> halve_list([5, 3, 5, 2, 3, 3, 9, 0, 123])
    """"""
    return [x / 2 for x in l]


def reciprocal_list(l: list):
    """"""Return list with elements reciprocaled.
    >>> reciprocal_list([1, 2, 3])
    >>> recipro",Error,ListArray
pairs_sum_to_zero,"

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    >>> pairs_sum_to_zero([1])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([1, 3, 5, 0]) == False
    assert candidate([1, 3, -2, 1]) == False
    assert candidate([1, 2, 3, 7]) == False
    assert candidate([2, 4, -5, 3, 5, 7]) == True
    assert candidate([1]) == False

    assert candidate([-3, 9, -1, 3, 2, 30]) == True
    assert candidate([-3, 9, -1, 3, 2, 31]) == True
    assert candidate([-3, 9, -1, 4, 2, 30]) == False
    assert candidate([-3, 9, -1, 4, 2, 31]) == False

","

def pairs_sum_to_zero(l):
    """"""
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    >>> pairs_sum_to_zero([1])
    """"""
    seen = set()
    for num in l:
        if -num in seen:
            return True
        seen.add(num)
    return False

# Test cases
print(pairs_sum_to_zero([1, 3, 5, 0]))  # Output: True
print(pairs_sum_to_zero([1, 3, -2, 1]))  # Output: True
print(pairs_sum_to_zero([1, 2, 3, 7]))  # Output: False
print(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]))  # Output: True
print(pairs_sum_to_zero([1]))  # Output: False
",Passed,ListArray
change_base,"

def change_base(x: int, base: int):
    """"""Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    >>> change_base(8, 3)
    >>> change_base(8, 2)
    >>> change_base(7, 2)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(8, 3) == ""22""
    assert candidate(9, 3) == ""100""
    assert candidate(234, 2) == ""11101010""
    assert candidate(16, 2) == ""10000""
    assert candidate(8, 2) == ""1000""
    assert candidate(7, 2) == ""111""
    for x in range(2, 8):
        assert candidate(x, x + 1) == str(x)

","

def change_base(x: int, base: int):
    """"""Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    >>> change_base(8, 3)
    >>> change_base(8, 2)
    >>> change_base(7, 2)
    """"""
    if base < 2 or base > 9:
        raise ValueError(""Base must be between 2 and 9"")
    if x == 0:
        return ""0""
    result = """"
    while x > 0:
        x, remainder = divmod(x, base)
        result = str(remainder) + result
    return result


def change_base_recursive(x: int, base: int):
    """"""Change numerical base of input number x to base.
    return string representation after the conversion.
    base numbers are less than 10.
    >>> change_base_recursive(8, 3)
    >>> change_base_recursive(8, 2)
    >>> change_base_recursive(7, 2)
    """"""
    if base < 2 or base > 9:
        raise ValueError(""Base must be between 2 and 9"")
    if x == 0:
        return ""0""
    if x == 1:
        return ""1""
    return change_base_recursive(x // base, base) + str(x % base)


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
triangle_area,"

def triangle_area(a, h):
    """"""Given length of a side and high return area for a triangle.
    >>> triangle_area(5, 3)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(5, 3) == 7.5
    assert candidate(2, 2) == 2.0
    assert candidate(10, 8) == 40.0

","

def triangle_area(a, h):
    """"""Given length of a side and high return area for a triangle.
    >>> triangle_area(5, 3)
    """"""
    return a * h / 2


def test_triangle_area():
    assert triangle_area(5, 3) == 15
    assert triangle_area(10, 2) == 10
    assert triangle_area(3, 7) == 21
    assert triangle_area(15, 10) == 75
    assert triangle_area(20, 15) == 150
    assert triangle_area(12, 6) == 36
    assert triangle_area(8, 4) == 24
    assert triangle_area(6, 3) == 15
    assert triangle_area(4, 2) == 4
    assert triangle_area(3, 1) == 3


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()
    test_triangle_area()",Passed,Math
fib4,"

def fib4(n: int):
    """"""The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    >>> fib4(5)
    >>> fib4(6)
    >>> fib4(7)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(5) == 4
    assert candidate(8) == 28
    assert candidate(10) == 104
    assert candidate(12) == 386

","

def fib4(n: int):
    """"""The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:
    fib4(0) -> 0
    fib4(1) -> 0
    fib4(2) -> 2
    fib4(3) -> 0
    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).
    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.
    >>> fib4(5)
    >>> fib4(6)
    >>> fib4(7)
    """"""
    if n == 0:
        return 0
    elif n == 1:
        return 0
    elif n == 2:
        return 2
    elif n == 3:
        return 0

    a, b, c, d = 0, 0, 2, 0
    for _ in range(4, n + 1):
        a, b, c, d = b, c, d, a + b + c + d

    return d


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
median,"

def median(l: list):
    """"""Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    >>> median([-10, 4, 6, 1000, 10, 20])
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate([3, 1, 2, 4, 5]) == 3
    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0
    assert candidate([5]) == 5
    assert candidate([6, 5]) == 5.5
    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 

","

def median(l: list):
    """"""Return median of elements in the list l.
    >>> median([3, 1, 2, 4, 5])
    >>> median([-10, 4, 6, 1000, 10, 20])
    """"""
    l.sort()
    if len(l) % 2 == 0:
        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2
    else:
        return l[len(l) // 2]


def main():
    print(median([3, 1, 2, 4, 5]))
    print(median([-10, 4, 6, 1000, 10, 20]))


if __name__ == ""__main__"":
    main()",Passed,Math
is_palindrome,"

def is_palindrome(text: str):
    """"""
    Checks if given string is a palindrome
    >>> is_palindrome('')
    >>> is_palindrome('aba')
    >>> is_palindrome('aaaaa')
    >>> is_palindrome('zbcd')
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate('') == True
    assert candidate('aba') == True
    assert candidate('aaaaa') == True
    assert candidate('zbcd') == False
    assert candidate('xywyx') == True
    assert candidate('xywyz') == False
    assert candidate('xywzx') == False

","

def is_palindrome(text: str):
    """"""
    Checks if given string is a palindrome
    >>> is_palindrome('')
    >>> is_palindrome('aba')
    >>> is_palindrome('aaaaa')
    >>> is_palindrome('zbcd')
    """"""
    if len(text) < 2:
        return True
    if text[0]!= text[-1]:
        return False
    return is_palindrome(text[1:-1])


if __name__ == '__main__':
    import doctest
    doctest.testmod()",Passed,String
modp,"

def modp(n: int, p: int):
    """"""Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    >>> modp(1101, 101)
    >>> modp(0, 101)
    >>> modp(3, 11)
    >>> modp(100, 101)
    """"""
","

METADATA = {}


def check(candidate):
    assert candidate(3, 5) == 3
    assert candidate(1101, 101) == 2
    assert candidate(0, 101) == 1
    assert candidate(3, 11) == 8
    assert candidate(100, 101) == 1
    assert candidate(30, 5) == 4
    assert candidate(31, 5) == 3

","

def modp(n: int, p: int):
    """"""Return 2^n modulo p (be aware of numerics).
    >>> modp(3, 5)
    >>> modp(1101, 101)
    >>> modp(0, 101)
    >>> modp(3, 11)
    >>> modp(100, 101)
    """"""
    return pow(2, n, p)


def modp_iter(n: int, p: int):
    """"""Return 2^n modulo p (be aware of numerics).
    >>> modp_iter(3, 5)
    >>> modp_iter(1101, 101)
    >>> modp_iter(0, 101)
    >>> modp_iter(3, 11)
    >>> modp_iter(100, 101)
    """"""
    result = 1
    base = 2
    while n > 0:
        if n % 2 == 1:
            result = (result * base) % p
        base = (base * base) % p
        n //= 2
    return result


if __name__ == ""__main__"":
    import doctest
    doctest.testmod()",Passed,Math
